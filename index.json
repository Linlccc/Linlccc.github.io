[{"content":" 实现原生的 AJAX 请求 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const ajax = { get(url, fn) { const xhr = new XMLHttpRequest(); xhr.open(\u0026#34;GET\u0026#34;, url, true); // 第三个参数异步与否 xhr.onreadystatechange = function () { if (xhr.readyState === 4) { fn(xhr.responeText); } }; xhr.send(); }, post(url, data, fn) { const xhr = new XMLHttpRequest(); xhr.open(\u0026#34;POST\u0026#34;, url, true); xhr.setRequestHeader(\u0026#34;Content-type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { fn(xhr.responeText); } }; xhr.send(data); }, }; 手写 new 的过程 # js 复制 1 2 3 4 5 6 7 8 9 function myNew(fn, ...args) { const obj = {}; obj.__proto__ = fn.prototype; fn.apply(obj, args); return obj; } instanceof 关键字 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 function instanceOf(father, child) { const fp = father.prototype; var cp = child.__proto__; while (cp) { if (cp === fp) { return true; } cp = cp.__proto__; } return false; } 实现防抖函数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 function debounce(fn, delay = 500) { let timer; return function () { if (timer) { clearTimeout(timer); } const args = arguments; timer = setTimeout(() =\u0026gt; { fn.apply(this, args); // 改变this指向为调用debounce所指的对象 }, delay); }; } 实现节流函数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 function throttle(fn, delay = 200) { let flag = true; return function () { if (!flag) return; flag = false; const args = arguments; setTimeout(() =\u0026gt; { fn.apply(this, args); flag = true; }, delay); }; } 实现数组去重 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 第一种：Map记录 function quchong1(arr) { const newArr = []; arr.reduce((pre, next) =\u0026gt; { if (!pre.has(next)) { pre.set(next, 1); newArr.push(next); } return pre; }, new Map()); return newArr; } // 第二种：Set去重 function quchong2(arr) { return [...new Set(arr)]; } 用 setTimeout 实现 setInterval # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function mySetTimout(fn, delay) { let timer = null; const interval = () =\u0026gt; { fn(); timer = setTimeout(interval, delay); }; setTimeout(interval, delay); return { cancel: () =\u0026gt; { clearTimeout(timer); }, }; } // 测试 const { cancel } = mySetTimout(() =\u0026gt; console.log(888), 1000); setTimeout(() =\u0026gt; { cancel(); }, 4000); 用 setInterval 实现 setTimeout # js 复制 1 2 3 4 5 6 7 8 9 function mySetInterval(fn, delay) { const timer = setInterval(() =\u0026gt; { fn(); clearInterval(timer); }, delay); } // 测试 mySetInterval(() =\u0026gt; console.log(888), 1000); 实现一个 compose 函数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function fn1(x) { return x + 1; } function fn2(x) { return x + 2; } function fn3(x) { return x + 3; } function fn4(x) { return x + 4; } const a = compose(fn1, fn2, fn3, fn4); console.log(a); console.log(a(1)); // 1+2+3+4=11 // 实现如下： function compose(...fn) { if (fn.length === 0) return (num) =\u0026gt; num; if (fn.length === 1) return fn[0]; return fn.reduce((pre, next) =\u0026gt; { return (num) =\u0026gt; { return next(pre(num)); }; }); } 实现一个科里化函数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const add = (a, b, c) =\u0026gt; a + b + c; const a = currying(add, 1); console.log(a(2, 3)); // 1 + 2 + 3=6 // 实现如下： function currying(fn, ...args1) { // 获取fn参数有几个 const length = fn.length; let allArgs = [...args1]; const res = (...arg2) =\u0026gt; { allArgs = [...allArgs, ...arg2]; // 长度相等就返回执行结果 if (allArgs.length === length) { return fn(...allArgs); } else { // 不相等继续返回函数 return res; } }; return res; } // 测试： const add = (a, b, c) =\u0026gt; a + b + c; const a = currying(add, 1); console.log(a(2, 3)); 实现一个 LRU 缓存函数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 实现如下： class LRUCache { constructor(size) { this.size = size; this.cache = new Map(); } get(key) { const hasKey = this.cache.has(key); if (hasKey) { const val = this.cache.get(key); this.cache.delete(key); this.cache.set(key, val); return val; } else { return -1; } } put(key, val) { const hasKey = this.cache.has(key); if (hasKey) { this.cache.delete(key); } this.cache.set(key, val); if (this.cache.size \u0026gt; this.size) { this.cache.delete(this.cache.keys().next().value); } } } 简单实现 发布订阅模式 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class EventEmitter { constructor() { this.cache = {}; } on(name, fn) { const tasks = this.cache[name]; if (tasks) { this.cache[name].push(fn); } else { this.cache[name] = [fn]; } } off(name, fn) { const tasks = this.cache[name]; if (task) { const index = tasks.findIndex((item) =\u0026gt; item === fn); if (index \u0026gt;= 0) { this.cache[name].splice(index, 1); } } } emit(name, ...args) { // 复制一份。防止回调里继续on，导致死循环 const tasks = this.cache[name].slice(); if (tasks) { for (let fn of tasks) { fn(...args); } } } once(name, cb) { function fn(...args) { cb(args); this.off(name, fn); } this.on(name, fn); } } 实现 JSON.parse # js 复制 1 2 3 function parse(json) { return eval(\u0026#34;(\u0026#34; + json + \u0026#34;)\u0026#34;); } 将 DOM 转化成树结构对象 # html 复制 1 2 3 4 5 6 7 \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 将上方的DOM转化为下面的树结构对象 { tag: \u0026#39;DIV\u0026#39;, children: [ { tag: \u0026#39;SPAN\u0026#39;, children: [] }, { tag: \u0026#39;UL\u0026#39;, children: [ { tag: \u0026#39;LI\u0026#39;, children: [] }, { tag: \u0026#39;LI\u0026#39;, children: [] } ] } ] } // 实现如下： function dom2tree(dom) { const obj = {} obj.tag = dom.tagName obj.children = [] dom.childNodes.forEach(child =\u0026gt; obj.children.push(dom2tree(child))) return obj } 将树结构转换为 DOM # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 树结构 {tag: \u0026#39;DIV\u0026#39;, children: [ { tag: \u0026#39;SPAN\u0026#39;, children: [] }, { tag: \u0026#39;UL\u0026#39;, children: [ { tag: \u0026#39;LI\u0026#39;, children: [] }, { tag: \u0026#39;LI\u0026#39;, children: [] } ] } ] } // 实现如下： // 真正的渲染函数 function _render(vnode) { // 如果是数字类型转化为字符串 if (typeof vnode === \u0026#34;number\u0026#34;) { vnode = String(vnode); } // 字符串类型直接就是文本节点 if (typeof vnode === \u0026#34;string\u0026#34;) { return document.createTextNode(vnode); } // 普通DOM const dom = document.createElement(vnode.tag); if (vnode.attrs) { // 遍历属性 Object.keys(vnode.attrs).forEach((key) =\u0026gt; { const value = vnode.attrs[key]; dom.setAttribute(key, value); }); } // 子数组进行递归操作 vnode.children.forEach((child) =\u0026gt; dom.appendChild(_render(child))); return dom; } html 复制 1 2 3 4 5 6 7 8 \u0026lt;!-- 转换后的dom --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 判断一个对象有环引用 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 var obj = { a: { c: [1, 2], }, b: 1, }; obj.a.c.d = obj; console.log(cycleDetector(obj)); // true // 实现思路：用一个数组存储每一个遍历过的对象，下次找到数组中存在，则说明环引用 function cycleDetector(obj) { const arr = [obj]; let flag = false; function cycle(o) { const keys = Object.keys(o); for (const key of keys) { const temp = o[key]; if (typeof temp === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; temp !== null) { if (arr.indexOf(temp) \u0026gt;= 0) { flag = true; return; } arr.push(temp); cycle(temp); } } } cycle(obj); return flag; } 计算一个对象的层数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const obj = { a: { b: [1] }, c: { d: { e: { f: 1 } } }, }; console.log(loopGetLevel(obj)); // 4 // 实现如下: function loopGetLevel(obj) { var res = 1; function computedLevel(obj, level) { var level = level ? level : 0; if (typeof obj === \u0026#34;object\u0026#34;) { for (var key in obj) { if (typeof obj[key] === \u0026#34;object\u0026#34;) { computedLevel(obj[key], level + 1); } else { res = level + 1 \u0026gt; res ? level + 1 : res; } } } else { res = level \u0026gt; res ? level : res; } } computedLevel(obj); return res; } 对象的扁平化 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 const obj = { a: { b: 1, c: 2, d: { e: 5 }, }, b: [1, 3, { a: 2, b: 3 }], c: 3, }; flatten(obj); // 结果返回如下 // { // \u0026#39;a.b\u0026#39;: 1, // \u0026#39;a.c\u0026#39;: 2, // \u0026#39;a.d.e\u0026#39;: 5, // \u0026#39;b[0]\u0026#39;: 1, // \u0026#39;b[1]\u0026#39;: 3, // \u0026#39;b[2].a\u0026#39;: 2, // \u0026#39;b[2].b\u0026#39;: 3 // c: 3 // } // 实现如下： const isObject = (val) =\u0026gt; typeof val === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; val !== null; function flatten(obj) { if (!isObject(obj)) return; const res = {}; const dfs = (cur, prefix) =\u0026gt; { if (isObject(cur)) { if (Array.isArray(cur)) { cur.forEach((item, index) =\u0026gt; { dfs(item, `${prefix}[${index}]`); }); } else { for (let key in cur) { dfs(cur[key], `${prefix}${prefix ? \u0026#34;.\u0026#34; : \u0026#34;\u0026#34;}${key}`); } } } else { res[prefix] = cur; } }; dfs(obj, \u0026#34;\u0026#34;); return res; } // 测试 console.log(flatten(obj)); 实现(a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3)为 true # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 第一种方法 var a = { i: 1, toString: function () { return a.i++; }, }; console.log(a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3); // true // 第二种方法 var a = [1, 2, 3]; a.join = a.shift; console.log(a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3); // true // 第三种方法 var val = 0; Object.defineProperty(window, \u0026#34;a\u0026#34;, { get: function () { return ++val; }, }); console.log(a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3); // true 实现限制并发的 Promise 调度器 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 addTask(1000, \u0026#34;1\u0026#34;); addTask(500, \u0026#34;2\u0026#34;); addTask(300, \u0026#34;3\u0026#34;); addTask(400, \u0026#34;4\u0026#34;); // 的输出顺序是：2 3 1 4 // 整个的完整执行流程： // 一开始1,2两个任务开始执行 // 500ms时，2任务执行完毕，输出2，任务3开始执行 // 800ms时，3任务执行完毕，输出3，任务4开始执行 // 1000ms时，1任务执行完毕，输出1，此时只剩下4任务在执行 // 1200ms时，4任务执行完毕，输出4 // 实现如下： class Scheduler { constructor(limit) { this.queue = []; this.limit = limit; this.count = 0; } add(time, order) { const promiseCreator = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(order); resolve(); }, time); }); }; this.queue.push(promiseCreator); } taskStart() { for (let i = 0; i \u0026lt; this.limit; i++) { this.request(); } } request() { if (!this.queue.length || this.count \u0026gt;= this.limit) return; this.count++; this.queue .shift()() .then(() =\u0026gt; { this.count--; this.request(); }); } } // 测试 const scheduler = new Scheduler(2); const addTask = (time, order) =\u0026gt; { scheduler.add(time, order); }; addTask(1000, \u0026#34;1\u0026#34;); addTask(500, \u0026#34;2\u0026#34;); addTask(300, \u0026#34;3\u0026#34;); addTask(400, \u0026#34;4\u0026#34;); scheduler.taskStart(); 实现 lazyMan 函数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // 实现一个LazyMan，可以按照以下方式调用: LazyMan(“Hank”) /** 输出: * Hi! This is Hank! */ LazyMan(“Hank”).sleep(10).eat(“dinner”) /** 输出: * Hi! This is Hank! * //等待10秒.. * Wake up after 10 * Eat dinner~ */ LazyMan(“Hank”).eat(“dinner”).eat(“supper”) /** 输出: * Hi This is Hank! * Eat dinner~ * Eat supper~ */ LazyMan(“Hank”).eat(“supper”).sleepFirst(5) /** 输出: * //等待5秒 * Wake up after 5 * Hi This is Hank! * Eat supper */ // 实现如下： class _LazyMan { constructor(name) { this.tasks = [] const task = () =\u0026gt; { console.log(`Hi! This is ${name}`) this.next() } this.tasks.push(task) setTimeout(() =\u0026gt; { this.next() }, 0) } next() { const task = this.tasks.shift() task \u0026amp;\u0026amp; task() } sleep(time) { this.sleepWrapper(time, false) return this } sleepFirst(time) { this.sleepWrapper(time, true) return this } sleepWrapper(time, first) { const task = () =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`Wake up after ${time}`) this.next() }, time * 1000) } if (first) { this.tasks.unshift(task) } else { this.tasks.push(task) } } eat(food) { const task = () =\u0026gt; { console.log(`Eat ${food}`); this.next(); }; this.tasks.push(task); return this; } } // 测试 const lazyMan = (name) =\u0026gt; new _LazyMan(name) lazyMan(\u0026#39;Hank\u0026#39;).sleep(1).eat(\u0026#39;dinner\u0026#39;) lazyMan(\u0026#39;Hank\u0026#39;).eat(\u0026#39;dinner\u0026#39;).eat(\u0026#39;supper\u0026#39;) lazyMan(\u0026#39;Hank\u0026#39;).eat(\u0026#39;supper\u0026#39;).sleepFirst(5) 实现 add 函数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 add(1)(2)(3)()=6 add(1,2,3)(4)()=10 function add(...args1) { let allArgs = [...args1] function fn(...args2) { if (!args2.length) return fn.toString() allArgs = [...allArgs, ...args2] return fn } fn.toString = function () { return allArgs.reduce((pre, next) =\u0026gt; pre + next) } return fn } // 测试 console.log(add(1)(2)(3)()) console.log(add(1, 2)(3)()) 实现一个合格的深拷贝 # 深拷贝有这 5 个段位？\n实现 Promise # 手写 Promise\n实现 async/await # 7 张图，20 分钟就能搞定的 async/await 原理\nforEach # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 参数代表含义 item：遍历项 index：遍历项的索引 arr：数组本身 Array.prototype.sx_forEach = function (callback) { for (let i = 0; i \u0026lt; this.length; i++) { callback(this[i], i, this) } } players.sx_forEach((item, index, arr) =\u0026gt; { console.log(item, index) }) // { name: \u0026#39;科比\u0026#39;, num: 24 } 0 // { name: \u0026#39;詹姆斯\u0026#39;, num: 23 } 1 // { name: \u0026#39;保罗\u0026#39;, num: 3 } 2 // { name: \u0026#39;威少\u0026#39;, num: 0 } 3 // { name: \u0026#39;杜兰特\u0026#39;, num: 35 } 4 map # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /**参数代表含义 * * item：遍历项 * index：遍历项的索引 * arr：数组本身 */ Array.prototype.sx_map = function (callback) { const res = []; for (let i = 0; i \u0026lt; this.length; i++) { res.push(callback(this[i], i, this)); } return res; }; console.log(players.sx_map((item, index) =\u0026gt; `${item.name}--${item.num}--${index}`)); // [ \u0026#39;科比--24--0\u0026#39;, \u0026#39;詹姆斯--23--1\u0026#39;, \u0026#39;保罗--3--2\u0026#39;, \u0026#39;威少--0--3\u0026#39;, \u0026#39;杜兰特--35--4\u0026#39; ] filter # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Array.prototype.sx_filter = function (callback) { const res = []; for (let i = 0; i \u0026lt; this.length; i++) { callback(this[i], i, this) \u0026amp;\u0026amp; res.push(this[i]); } return res; }; console.log(players.sx_filter((item) =\u0026gt; item.num \u0026gt;= 23)); // [ // { name: \u0026#39;科比\u0026#39;, num: 24 }, // { name: \u0026#39;詹姆斯\u0026#39;, num: 23 }, // { name: \u0026#39;杜兰特\u0026#39;, num: 35 } // ] every # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 Array.prototype.sx_every = function (callback) { let flag = true; for (let i = 0; i \u0026lt; this.length; i++) { flag = callback(this[i], i, this); if (!flag) break; } return flag; }; console.log(players.sx_every((item) =\u0026gt; item.num \u0026gt;= 23)); // false console.log(players.sx_every((item) =\u0026gt; item.num \u0026gt;= 0)); // true some # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 Array.prototype.sx_some = function (callback) { let flag = false; for (let i = 0; i \u0026lt; this.length; i++) { flag = callback(this[i], i, this); if (flag) break; } return flag; }; console.log(players.sx_some((item) =\u0026gt; item.num \u0026gt;= 23)); // true console.log(players.sx_some((item) =\u0026gt; item.num \u0026gt;= 50)); // false reduce # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /**参数代表含义 * * pre：前一项 * next：下一项 * index：当前索引 * arr：数组本身 */ Array.prototype.sx_reduce = function (callback, ...args) { let start = 0, pre; if (args.length) { pre = args[0]; } else { pre = this[0]; start = 1; } for (let i = start; i \u0026lt; this.length; i++) { pre = callback(pre, this[i], i, this); } return pre; }; // 计算所有num相加 const sum = players.sx_reduce((pre, next) =\u0026gt; { return pre + next.num; }, 0); console.log(sum); // 85 findIndex # js 复制 1 2 3 4 5 6 7 8 9 10 11 Array.prototype.sx_findIndex = function (callback) { for (let i = 0; i \u0026lt; this.length; i++) { if (callback(this[i], i, this)) { return i; } } return -1; }; console.log(players.sx_findIndex((item) =\u0026gt; item.name === \u0026#34;科比\u0026#34;)); // 0 console.log(players.sx_findIndex((item) =\u0026gt; item.name === \u0026#34;安东尼\u0026#34;)); // -1 find # js 复制 1 2 3 4 5 6 7 8 9 10 11 Array.prototype.sx_find = function (callback) { for (let i = 0; i \u0026lt; this.length; i++) { if (callback(this[i], i, this)) { return this[i]; } } return undefined; }; console.log(players.sx_find((item) =\u0026gt; item.name === \u0026#34;科比\u0026#34;)); // { name: \u0026#39;科比\u0026#39;, num: 24 } console.log(players.sx_find((item) =\u0026gt; item.name === \u0026#34;安东尼\u0026#34;)); // undefined fill # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /**参数代表含义 * * initValue：填充的值 * start：开始填充索引，默认0 * end：结束填充索引，默认length */ // 用处：填充数组 Array.prototype.sx_fill = function (value, start = 0, end) { end = end || this.length; for (let i = start; i \u0026lt; end; i++) { this[i] = value; } return this; }; console.log(players.sx_fill(\u0026#34;林三心\u0026#34;, 1, 3)); // [ // { name: \u0026#39;科比\u0026#39;, num: 24 }, // \u0026#39;林三心\u0026#39;, // \u0026#39;林三心\u0026#39;, // \u0026#39;林三心\u0026#39;, // { name: \u0026#39;杜兰特\u0026#39;, num: 35 } // ] includes # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 用处：查找元素，查到返回true，反之返回false，可查找NaN Array.prototype.sx_includes = function (value, start = 0) { if (start \u0026lt; 0) start = this.length + start const isNaN = Number.isNaN(value) for (let i = start; i \u0026lt; this.length; i++) { if (this[i] === value || (isNaN \u0026amp;\u0026amp; Number.isNaN(this[i])) { return true } } return false } console.log([1, 2, 3].sx_includes(2)) // true console.log([1, 2, 3, NaN].sx_includes(NaN)) // true console.log([1, 2, 3].sx_includes(1, 1)) // false join # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 // 用处：将数组用分隔符拼成字符串，分隔符默认为, Array.prototype.sx_join = function (s = \u0026#34;,\u0026#34;) { let str = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; this.length; i++) { str = i === 0 ? `${str}${this[i]}` : `${str}${s}${this[i]}`; } return str; }; console.log([1, 2, 3].sx_join()); // 1,2,3 console.log([1, 2, 3].sx_join(\u0026#34;*\u0026#34;)); // 1*2*3 flat # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Array.prototype.sx_flat = function (num = Infinity) { let arr = this; let i = 0; while (arr.some((item) =\u0026gt; Array.isArray(item))) { arr = [].concat(...arr); i++; if (i \u0026gt;= num) break; } return arr; }; const testArr = [1, [2, 3, [4, 5]], [8, 9]]; console.log(testArr.sx_flat(1)); // [1, 2, 3, 4, 5, 8, 9] splice # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Array.prototype.sx_splice = function (start, length, ...values) { if (length === 0) return []; length = start + length \u0026gt; this.length - 1 ? this.length - start : length; console.log(length); const res = [], tempArr = [...this]; for (let i = start; i \u0026lt; start + values.length; i++) { this[i] = values[i - start]; } this.length = start + values.length; if (values.length \u0026lt; length) { const cha = length - values.length; console.log(cha); for (let i = start + values.length; i \u0026lt; tempArr.length; i++) { this[i] = tempArr[i + cha]; } this.length = this.length - cha; } if (values.length \u0026gt; length) { for (let i = start + length; i \u0026lt; tempArr.length; i++) { this.push(tempArr[i]); } } for (let i = start; i \u0026lt; start + length; i++) { res.push(tempArr[i]); } return res; }; entries # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 用处：将对象转成键值对数组 Object.prototype.sx_entries = function (obj) { const res = [] for (let key in obj) { obj.hasOwnProperty(key) \u0026amp;\u0026amp; res.push([key, obj[key]]) } return res } console.log(Object.sx_entries(obj)) // [ [ \u0026#39;name\u0026#39;, \u0026#39;林三心\u0026#39; ], [ \u0026#39;age\u0026#39;, 22 ], [ \u0026#39;gender\u0026#39;, \u0026#39;男\u0026#39; ] ] fromEntries # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 用处：跟entries相反，将键值对数组转成对象 Object.prototype.sx_fromEntries = function (arr) { const obj = {}; for (let i = 0; i \u0026lt; arr.length; i++) { const [key, value] = arr[i]; obj[key] = value; } return obj; }; console.log( Object.sx_fromEntries([ [\u0026#34;name\u0026#34;, \u0026#34;林三心\u0026#34;], [\u0026#34;age\u0026#34;, 22], [\u0026#34;gender\u0026#34;, \u0026#34;男\u0026#34;], ]), ); // { name: \u0026#39;林三心\u0026#39;, age: 22, gender: \u0026#39;男\u0026#39; } keys # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 // 用处：将对象的key转成一个数组合集 Object.prototype.sx_keys = function (obj) { const keys = []; for (let key in obj) { obj.hasOwnProperty(key) \u0026amp;\u0026amp; res.push(key); } return keys; }; console.log(Object.keys(obj)); // [ \u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39; ] values # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 // 用处：将对象的所有值转成数组合集 Object.prototype.sx_values = function (obj) { const values = []; for (let key in obj) { obj.hasOwnProperty(key) \u0026amp;\u0026amp; values.push(obj[key]); } return values; }; console.log(Object.sx_values(obj)); // [ \u0026#39;林三心\u0026#39;, 22, \u0026#39;男\u0026#39; ] instanceOf # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 用处：A instanceOf B，判断A是否经过B的原型链 function instanceOf(father, child) { const fp = father.prototype; var cp = child.__proto__; while (cp) { if (cp === fp) { return true; } cp = cp.__proto__; } return false; } function Person(name) { this.name = name; } const sx = new Person(\u0026#34;林三心\u0026#34;); console.log(instanceOf(Person, sx)); // true console.log(instanceOf(Person, sx2)); // false is # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 用处：Object.is(a, b)，判断a是否等于b Object.prototype.sx_is = function (x, y) { if (x === y) { // 防止 -0 和 +0 return x !== 0 || 1 / x === 1 / y; } // 防止NaN return x !== x \u0026amp;\u0026amp; y !== y; }; const a = { name: \u0026#34;林三心\u0026#34; }; const b = a; const c = { name: \u0026#34;林三心\u0026#34; }; console.log(Object.sx_is(a, b)); // true console.log(Object.sx_is(a, c)); // false Object.assign # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /**难点 * * assign接收多个对象，并将多个对象合成一个对象 * 这些对象如果有重名属性，以后来的对象属性值为准 * assign返回一个对象，这个对象 === 第一个对象 */ Object.prototype.sx_assign = function (target, ...args) { if (target === null || target === undefined) { throw new TypeError(\u0026#34;Cannot convert undefined or null to object\u0026#34;); } target = Object(target); for (let nextObj of args) { for (let key in nextObj) { nextObj.hasOwnProperty(key) \u0026amp;\u0026amp; (target[key] = nextObj[key]); } } return target; }; const testa = { name: \u0026#34;林三心\u0026#34; }; const testb = { name: \u0026#34;sunshine_lin\u0026#34;, age: 22 }; const testc = { age: 18, gender: \u0026#34;男\u0026#34; }; const testd = Object.sx_assign(testa, testb, testc); console.log(testd); // { name: \u0026#39;sunshine_lin\u0026#39;, age: 18, gender: \u0026#39;男\u0026#39; } console.log(testa === testd); // true Function 篇\ncall # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Function.prototype.sx_call = function (obj, ...args) { obj = obj || window; // Symbol是唯一的，防止重名key const fn = Symbol(); obj[fn] = this; // 执行，返回执行值 return obj[fn](...args); }; const testobj = { name: \u0026#34;林三心\u0026#34;, testFn(age) { console.log(`${this.name}${age}岁了`); }, }; const testobj2 = { name: \u0026#34;sunshine_lin\u0026#34;, }; testobj.testFn.sx_call(testobj2, 22); // sunshine_lin22岁了 apply # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Function.prototype.sx_apply = function (obj, args) { obj = obj || window; // Symbol是唯一的，防止重名key const fn = Symbol(); obj[fn] = this; // 执行，返回执行值 return obj[fn](...args); }; const testobj = { name: \u0026#34;林三心\u0026#34;, testFn(age) { console.log(`${this.name}${age}岁了`); }, }; const testobj2 = { name: \u0026#34;sunshine_lin\u0026#34;, }; testobj.testFn.sx_apply(testobj2, [22]); // sunshine_lin22岁了 Function.prototype.bind # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /**难点： * * bind是返回一个函数，而不是执行结果 * bind返回的函数，拿来当做构造函数，该怎么处理 */ Function.prototype.sx_bind = function (obj, ...args) { obj = obj || window; // Symbol是唯一的，防止重名key const fn = Symbol(); obj[fn] = this; const _this = this; const res = function (...innerArgs) { console.log(this, _this); if (this instanceof _this) { this[fn] = _this; this[fn](...[...args, ...innerArgs]); delete this[fn]; } else { obj[fn](...[...args, ...innerArgs]); delete obj[fn]; } }; res.prototype = Object.create(this.prototype); return res; }; String 篇\nslice # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /**参数代表含义 * * start：开始截取的字符索引(包含此字符) * end：结束截取的字符索引(不包含此字符) 注意点 * start \u0026gt; end：返回空字符串 * start \u0026lt; 0：start = 数组长度 + start */ String.prototype.sx_slice = function (start = 0, end) { start = start \u0026lt; 0 ? this.length + start : start; end = !end \u0026amp;\u0026amp; end !== 0 ? this.length : end; if (start \u0026gt;= end) return \u0026#34;\u0026#34;; let str = \u0026#34;\u0026#34;; for (let i = start; i \u0026lt; end; i++) { str += this[i]; } return str; }; console.log(str.sx_slice(2)); // nshine_lin console.log(str.sx_slice(-2)); // in console.log(str.sx_slice(-9, 10)); // shine_l console.log(str.sx_slice(5, 1)); // \u0026#39;\u0026#39; substr # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /**参数代表含义 * * start：开始截取的字符索引(包含此字符) * length：截取的长度 注意点 * start \u0026lt; 0：start = 数组长度 + start * length超出所能截取范围，需要做处理 * length \u0026lt; 0：返回空字符串 */ String.prototype.sx_substr = function (start = 0, length) { if (length \u0026lt; 0) return \u0026#34;\u0026#34;; start = start \u0026lt; 0 ? this.length + start : start; length = (!length \u0026amp;\u0026amp; length !== 0) || length \u0026gt; this.length - start ? this.length : start + length; let str = \u0026#34;\u0026#34;; for (let i = start; i \u0026lt; length; i++) { str += this[i]; } return str; }; console.log(str.sx_substr(3)); // shine_lin console.log(str.sx_substr(3, 3)); // shi console.log(str.sx_substr(5, 300)); // ine_lin substring # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 功能与slice大致相同 // 区别之处 // start \u0026gt; end：互换值 String.prototype.sx_sunstring = function (start = 0, end) { start = start \u0026lt; 0 ? this.length + start : start; end = !end \u0026amp;\u0026amp; end !== 0 ? this.length : end; if (start \u0026gt;= end) [start, end] = [end, start]; let str = \u0026#34;\u0026#34;; for (let i = start; i \u0026lt; end; i++) { str += this[i]; } return str; }; console.log(str.sx_sunstring(2)); // nshine_lin console.log(str.sx_sunstring(-2)); // in console.log(str.sx_sunstring(-9, 10)); // shine_l console.log(str.sx_sunstring(5, 1)); // unsh Promise 篇\nall # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 接收一个Promise数组，数组中如有非Promise项，则此项当做成功 // 如果所有Promise都成功，则返回成功结果数组 // 如果有一个Promise失败，则返回这个失败结果 function all(promises) { const result = []; let count = 0; return new MyPromise((resolve, reject) =\u0026gt; { const addData = (index, value) =\u0026gt; { result[index] = value; count++; if (count === promises.length) resolve(result); }; promises.forEach((promise, index) =\u0026gt; { if (promise instanceof MyPromise) { promise.then( (res) =\u0026gt; { addData(index, res); }, (err) =\u0026gt; reject(err), ); } else { addData(index, promise); } }); }); } race # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 接收一个Promise数组，数组中如有非Promise项，则此项当做成功 // 哪个Promise最快得到结果，就返回那个结果，无论成功失败 function race(promises) { return new MyPromise((resolve, reject) =\u0026gt; { promises.forEach((promise) =\u0026gt; { if (promise instanceof MyPromise) { promise.then( (res) =\u0026gt; { resolve(res); }, (err) =\u0026gt; { reject(err); }, ); } else { resolve(promise); } }); }); } allSettled # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 接收一个Promise数组，数组中如有非Promise项，则此项当做成功 // 把每一个Promise的结果，集合成数组，返回 function allSettled(promises) { return new Promise((resolve, reject) =\u0026gt; { const res = []; let count = 0; const addData = (status, value, i) =\u0026gt; { res[i] = { status, value, }; count++; if (count === promises.length) { resolve(res); } }; promises.forEach((promise, i) =\u0026gt; { if (promise instanceof MyPromise) { promise.then( (res) =\u0026gt; { addData(\u0026#34;fulfilled\u0026#34;, res, i); }, (err) =\u0026gt; { addData(\u0026#34;rejected\u0026#34;, err, i); }, ); } else { addData(\u0026#34;fulfilled\u0026#34;, promise, i); } }); }); } any # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // any与all相反 // 接收一个Promise数组，数组中如有非Promise项，则此项当做成功 // 如果有一个Promise成功，则返回这个成功结果 // 如果所有Promise都失败，则报错 function any(promises) { return new Promise((resolve, reject) =\u0026gt; { let count = 0; promises.forEach((promise) =\u0026gt; { promise.then( (val) =\u0026gt; { resolve(val); }, (err) =\u0026gt; { count++; if (count === promises.length) { reject(new AggregateError(\u0026#34;All promises were rejected\u0026#34;)); } }, ); }); }); } finally # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 接收一个回调函数，但无参数接收 // 无论成功失败状态，都会执行finally Promise.prototype.finally = function (callback) { return this.then( (res) =\u0026gt; { callback(); return res; }, (err) =\u0026gt; { callback(); throw err; }, ); }; ","permalink":"https://linlccc.com/pending/adv-js-knowledge/","summary":"实现原生的 AJAX 请求 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const ajax = { get(url, fn) { const xhr = new XMLHttpRequest(); xhr.open(\u0026#34;GET\u0026#34;, url, true); // 第三个参数异步与否 xhr.onreadystatechange = function () { if (xhr.readyState === 4) {","title":"手写js高级知识点"},{"content":" 文章基础配置 # yaml 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # 标题 title: # 链接标题，在标题很长时用到 linkTitle: # 描述 description: # 摘要,如果为空自动截取文章内容 Summary: # 隐藏摘要 hideSummary: false # 权重 weight: 1000 # 是否是草稿 draft: false # 日期 date: 2000-10-01 12:00:00 # 发布日期 publishDate: 2000-10-01 12:00:00 # 过期日期 expiryDate: 2000-10-01 12:00:00 # 最后修改日期，enableGitInfo 设置为true后会自动设置成 git 提交日期 lastmod: 2000-10-01 12:00:00 # 别名，用于重定向 (比如: /post/[aliases]/ 会重定向到当前页面) aliases: - aaa # 页面链接 url: /aaa # 标签 tags: - tag1 - tag2 # 语言 langs: - C++ # 关键字 keywords: - key1 - key2 # 分类 categories: - category1 - category2 # hugo 内置模板 Open Graph 的配置(一般用不到) # 声音文件 audio: - \u0026#34;default.mp3\u0026#34; # 图像文件 images: - post-cover.png # 视频文件 videos: - video.mp4 模板查找配置 # yaml 复制 1 2 3 4 # 布局，该设置会优先去找 test.html 模板 layout: test # 类型，该设置会优先在 test 目录下去找模板 type: test 自定义配置 # yaml 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # 作者 authors: - author1 - author2 # 显示面包屑导航 ShowBreadCrumbs: true # 隐藏元数据（比如作者、发布日期等） hidemeta: false # 显示文章阅读时间 ShowReadingTime: true # 显示文章字数统计 ShowWordCount: true # 显示作者 showAuthor: true # 显示原文章信息，用于显示转载自哪里 showCanonicalLink: true # 原文章链接 canonicalLink: # 显示目录 showToc: true # 打开目录 tocOpen: false # 显示文章导航链接(上/下页) showPostNavLinks: true # 禁用分享功能 disableShare: false # 禁用锚定标题 disableAnchoredHeadings: false # giscus 评论信息 giscusCommentsInfo: enabled: true # 在站内搜索结果中隐藏页面 searchHidden: true # 从 home 页中隐藏，值只能是true/false hiddenInHomeList: false # 文章封面 cover: # 封面图片 image: \u0026#34;\u0026#34; # 图片的替代文本 alt: \u0026#34;\u0026#34; # 封面标题，描述 caption: \u0026#34;\u0026#34; # 指示图片路径是否相对于当前文件 relative: false # 在列表中隐藏封面 hiddenInList: false # 在文章页面中隐藏封面 hiddenInSingle: false # 文章编辑链接信息 editPost: # 链接(示例链接指向githu的修改) url: https://github.com/[YourName]/[Repo]/edit/master/src/content # 将文件路径附加到编辑链接 appendFilePath: true # 禁用编辑 disabled: false # 在新页面打开 openInNewPage: false ","permalink":"https://linlccc.com/posts/hugo-hahahthemearticleconfiguration/","summary":"文章基础配置 # yaml 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # 标题 title:","title":"Hugo-Hahah 主题文章配置"},{"content":" C# 多线程第一页内容 # ","permalink":"https://linlccc.com/series/csharpmultithreading/one/","summary":"C# 多线程第一页内容 #","title":"C# 多线程第一页"},{"content":" C# 多线程首页内容 # ","permalink":"https://linlccc.com/series/csharpmultithreading/zero/","summary":"C# 多线程首页内容 #","title":"C# 多线程首页"},{"content":" 测试系列 # ","permalink":"https://linlccc.com/series/test/zero/","summary":"测试系列 #","title":"测试系列"},{"content":" 防抖 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function debounce(fn, delay) { let timer; return function (...args) { timer \u0026amp;\u0026amp; clearTimeout(timer); timer = setTimeout(() =\u0026gt; fn.apply(this, args), delay); }; } // 测试 function task(arg) { console.log(\u0026#34;run task\u0026#34; + arg); } const debounceTask = debounce(task, 1000); window.addEventListener(\u0026#34;scroll\u0026#34;, () =\u0026gt; debounceTask(11)); 节流 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function throttle(fn, delay) { let last = 0; return function (...args) { const now = Date.now(); if (now - last \u0026lt; delay) return; last = now; fn.apply(this, args); }; } // 测试 function task() { console.log(\u0026#34;run task\u0026#34;); } const throttleTask = throttle(task, 1000); window.addEventListener(\u0026#34;scroll\u0026#34;, throttleTask); 深拷贝 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function deepClone(obj, cache = new WeakMap()) { if (typeof obj !== \u0026#34;object\u0026#34;) return obj; // 普通类型，直接返回 if (obj === null) return obj; if (cache.get(obj)) return cache.get(obj); // 防止循环引用，程序进入死循环 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 找到所属原型上的constructor，所属原型上的constructor指向当前对象的构造函数 let cloneObj = new obj.constructor(); cache.set(obj, cloneObj); // 缓存拷贝的对象，用于处理循环引用的情况 for (let key in obj) { if (obj.hasOwnProperty(key)) { cloneObj[key] = deepClone(obj[key], cache); // 递归拷贝 } } return cloneObj; } // 测试 const obj = { name: \u0026#34;Jack\u0026#34;, address: { x: 100, y: 200 } }; obj.a = obj; // 循环引用 const newObj = deepClone(obj); console.log(newObj.address === obj.address); // false 手写 Promise # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class MyPromise { constructor(executor) { // executor执行器 this.status = \u0026#34;pending\u0026#34;; // 等待状态 this.value = null; // 成功或失败的参数 this.fulfilledCallbacks = []; // 成功的函数队列 this.rejectedCallbacks = []; // 失败的函数队列 const that = this; function resolve(value) { // 成功的方法 if (that.status === \u0026#34;pending\u0026#34;) { that.status = \u0026#34;resolved\u0026#34;; that.value = value; that.fulfilledCallbacks.forEach((myFn) =\u0026gt; myFn(that.value)); //执行回调方法 } } function reject(value) { //失败的方法 if (that.status === \u0026#34;pending\u0026#34;) { that.status = \u0026#34;rejected\u0026#34;; that.value = value; that.rejectedCallbacks.forEach((myFn) =\u0026gt; myFn(that.value)); //执行回调方法 } } try { executor(resolve, reject); } catch (err) { reject(err); } } then(onFulfilled, onRejected) { if (this.status === \u0026#34;pending\u0026#34;) { // 等待状态，添加回调函数到成功的函数队列 this.fulfilledCallbacks.push(() =\u0026gt; { onFulfilled(this.value); }); // 等待状态，添加回调函数到失败的函数队列 this.rejectedCallbacks.push(() =\u0026gt; { onRejected(this.value); }); } if (this.status === \u0026#34;resolved\u0026#34;) { // 支持同步调用 console.log(\u0026#34;this\u0026#34;, this); onFulfilled(this.value); } if (this.status === \u0026#34;rejected\u0026#34;) { // 支持同步调用 onRejected(this.value); } } } // 测试 function fn() { return new MyPromise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { if (Math.random() \u0026gt; 0.6) { resolve(1); } else { reject(2); } }, 1000); }); } fn().then( (res) =\u0026gt; { console.log(\u0026#34;res\u0026#34;, res); // res 1 }, (err) =\u0026gt; { console.log(\u0026#34;err\u0026#34;, err); // err 2 }, ); 异步控制并发数 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function limitRequest(urls = [], limit = 5) { return new Promise((resolve, reject) =\u0026gt; { const len = urls.length; let count = 0; // 当前进行到第几个任务 const start = async () =\u0026gt; { const url = urls.shift(); // 从数组中拿取第一个任务 if (url) { try { await axios.post(url); if (count == len - 1) { // 最后一个任务 resolve(); } else { count++; // 成功，启动下一个任务 start(); } } catch (e) { count++; // 失败，也启动下一个任务 start(); } } }; // 启动limit个任务 while (limit \u0026gt; 0) { start(); limit -= 1; } }); } // 测试 limitRequest([\u0026#34;http://xxa\u0026#34;, \u0026#34;http://xxb\u0026#34;, \u0026#34;http://xxc\u0026#34;, \u0026#34;http://xxd\u0026#34;, \u0026#34;http://xxe\u0026#34;]); 继承 # ES5 继承 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function Parent(name) { this.name = name; } Parent.prototype.eat = function () { console.log(this.name + \u0026#34; is eating\u0026#34;); }; function Child(name, age) { Parent.call(this, name); this.age = age; } Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child; // 测试 let xm = new Child(\u0026#34;xiaoming\u0026#34;, 12); console.log(xm.name); // xiaoming console.log(xm.age); // 12 xm.eat(); // xiaoming is eating ES6 继承 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Parent { constructor(name) { this.name = name; } eat() { console.log(this.name + \u0026#34; is eating\u0026#34;); } } class Child extends Parent { constructor(name, age) { super(name); this.age = age; } } // 测试 let xm = new Child(\u0026#34;xiaoming\u0026#34;, 12); console.log(xm.name); // xiaoming console.log(xm.age); // 12 xm.eat(); // xiaoming is eating 数组排序 # sort 排序 # js 复制 1 2 3 4 5 6 7 8 9 // 对数字进行排序，简写 const arr = [3, 2, 4, 1, 5]; arr.sort((a, b) =\u0026gt; a - b); console.log(arr); // [1, 2, 3, 4, 5] // 对字母进行排序，简写 const arr = [\u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;d\u0026#34;]; arr.sort(); console.log(arr); // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] 冒泡排序 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function bubbleSort(arr) { let len = arr.length; for (let i = 0; i \u0026lt; len - 1; i++) { // 从第一个元素开始，比较相邻的两个元素，前者大就交换位置 for (let j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { let num = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = num; } } // 每次遍历结束，都能找到一个最大值，放在数组最后 } return arr; } //测试 console.log(bubbleSort([2, 3, 1, 5, 4])); // [1, 2, 3, 4, 5] 数组去重 # Set 去重 # js 复制 1 2 cosnt newArr = [...new Set(arr)]; const newArr = Array.from(new Set(arr)); indexOf 去重 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 function resetArr(arr) { let res = []; arr.forEach((item) =\u0026gt; { if (res.indexOf(item) === -1) { res.push(item); } }); return res; } // 测试 const arr = [1, 1, 2, 3, 3]; console.log(resetArr(arr)); // [1, 2, 3] 获取 url 参数 # URLSearchParams 方法 # js 复制 1 2 3 4 // 创建一个URLSearchParams实例 const urlSearchParams = new URLSearchParams(window.location.search); // 把键值对列表转换为一个对象 const params = Object.fromEntries(urlSearchParams.entries()); split 方法 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function getParams(url) { const res = {}; if (url.includes(\u0026#34;?\u0026#34;)) { const str = url.split(\u0026#34;?\u0026#34;)[1]; const arr = str.split(\u0026#34;\u0026amp;\u0026#34;); arr.forEach((item) =\u0026gt; { const key = item.split(\u0026#34;=\u0026#34;)[0]; const val = item.split(\u0026#34;=\u0026#34;)[1]; res[key] = decodeURIComponent(val); // 解码 }); } return res; } // 测试 const user = getParams(\u0026#34;http://www.baidu.com?user=%E9%98%BF%E9%A3%9E\u0026amp;age=16\u0026#34;); console.log(user); // { user: \u0026#39;阿飞\u0026#39;, age: \u0026#39;16\u0026#39; } 发布订阅模式 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class EventEmitter { constructor() { this.cache = {}; } on(name, fn) { if (this.cache[name]) { this.cache[name].push(fn); } else { this.cache[name] = [fn]; } } off(name, fn) { const tasks = this.cache[name]; if (tasks) { const index = tasks.findIndex((f) =\u0026gt; f === fn || f.callback === fn); if (index \u0026gt;= 0) { tasks.splice(index, 1); } } } emit(name, once = false) { if (this.cache[name]) { // 创建副本，如果回调函数内继续注册相同事件，会造成死循环 const tasks = this.cache[name].slice(); for (let fn of tasks) { fn(); } if (once) { delete this.cache[name]; } } } } // 测试 const eventBus = new EventEmitter(); const task1 = () =\u0026gt; { console.log(\u0026#34;task1\u0026#34;); }; const task2 = () =\u0026gt; { console.log(\u0026#34;task2\u0026#34;); }; eventBus.on(\u0026#34;task\u0026#34;, task1); eventBus.on(\u0026#34;task\u0026#34;, task2); eventBus.off(\u0026#34;task\u0026#34;, task1); setTimeout(() =\u0026gt; { eventBus.emit(\u0026#34;task\u0026#34;); // task2 }, 1000); ","permalink":"https://linlccc.com/pending/commonlyusedjs/","summary":"防抖 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function debounce(fn, delay) { let timer; return function (...args) { timer \u0026amp;\u0026amp; clearTimeout(timer); timer = setTimeout(() =\u0026gt; fn.apply(this, args), delay); }; } // 测试 function task(arg) { console.log(\u0026#34;run task\u0026#34; + arg); } const debounceTask = debounce(task, 1000); window.addEventListener(\u0026#34;scroll\u0026#34;, () =\u0026gt; debounceTask(11)); 节流 # js 复制 1 2","title":"常用js"},{"content":" 防抖 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function debounce(fn, delay) { let timer; return function (...args) { timer \u0026amp;\u0026amp; clearTimeout(timer); timer = setTimeout(() =\u0026gt; fn.apply(this, args), delay); }; } // 测试 function task(arg) { console.log(\u0026#34;run task\u0026#34; + arg); } const debounceTask = debounce(task, 1000); window.addEventListener(\u0026#34;scroll\u0026#34;, () =\u0026gt; debounceTask(11)); 节流 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function throttle(fn, delay) { let last = 0; return function (...args) { const now = Date.now(); if (now - last \u0026lt; delay) return; last = now; fn.apply(this, args); }; } // 测试 function task() { console.log(\u0026#34;run task\u0026#34;); } const throttleTask = throttle(task, 1000); window.addEventListener(\u0026#34;scroll\u0026#34;, throttleTask); ","permalink":"https://linlccc.com/posts/commonlyusedjs/","summary":"防抖 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function debounce(fn, delay) { let timer; return function (...args) { timer \u0026amp;\u0026amp; clearTimeout(timer); timer = setTimeout(() =\u0026gt; fn.apply(this, args), delay); }; } // 测试 function task(arg) { console.log(\u0026#34;run task\u0026#34; + arg); } const debounceTask = debounce(task, 1000); window.addEventListener(\u0026#34;scroll\u0026#34;, () =\u0026gt; debounceTask(11)); 节流 # js 复制 1 2","title":"常用js"},{"content":" 基础工具 # 7z 压缩\nTrafficMonitor 任务栏数据显示\nPowerToys Windows 增强工具\nListArr 文件搜索\nFoxmail 邮件管理\nNeatDownloadManager 下载管理\nDitto 粘贴板\nQttabbar Windows10 文件管理器多标签\n浏览器 # Google Chrome\n编辑器 # Visual Studio\nVS Code\nNotepad++\nObsidian Markdown 编辑器\n远程 # 1Remote 【推荐】\nMobaXterm\nWindTerm\nFileZilla FTP 工具\n内网穿透 # Frp\nNatfrp 提供内网穿透服务\n服务挂载 # nssm\n数据库 # Mysql\nSqlServer\nNavicat\nRedis\n源代码管理 # SVN\n代理 # Nginx\n","permalink":"https://linlccc.com/posts/mostusedsoftwares/","summary":"基础工具 # 7z 压缩 TrafficMonitor 任务栏数据显示 PowerToys Windows 增强工具 ListArr 文件搜索 Foxmail 邮件管理 NeatDownloadManager 下载管理 Ditto 粘贴板 Qttabbar Windows10 文件管理器多标签 浏览器 # Google Chrome 编辑器 # Visual Studio VS Code Notepad++ Obsidian Markdown 编辑","title":"常用软件"},{"content":" 基础扩展 # Chinese (Simplified) # 插件 txt 复制 1 VS Code 的中文（简体）语言包 vscode-icons # 插件 txt 复制 1 图标 XML，Json，TOML 扩展 # JSON Crack # 插件 txt 复制 1 Json 数据可视化 Even Better TOML # 插件 txt 复制 1 TOML 语言支持 Markdown All in One # 插件 txt 复制 1 Markdown 快捷键等支持 Markdown Preview Enhanced # 插件 txt 复制 1 Markdown 预览 markdownlint # 插件 txt 复制 1 Markdown 语法检查 C# 扩展 # .NET Install Tool # 插件 txt 复制 1 此扩展安装和管理不同版本的 .NET SDK 和运行时 C# # 插件 依赖 .NET Install Tool txt 复制 1 C# 的基本语言支持 C# Dev Kit # 插件 依赖 .NET Install Tool C# txt 复制 1 2 3 帮助 C# 开发人员更快、更快速地编写、调试和维护其代码 ps: 此扩展依赖以上两个扩展，直接安装该扩展即可 Js 扩展 # EsLint # 插件 中文官网 规则参考 txt 复制 1 2 3 4 5 6 JavaScript 语法检查工具 规则配置： \u0026#34;off\u0026#34; 或 0 - 关闭规则 \u0026#34;warn\u0026#34; 或 1 - 启用并视作警告（不影响退出） \u0026#34;error\u0026#34; 或 2 - 启用并视作错误（触发时退出代码为 1） 常用规则 json 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 rules: { // 箭头函数的参数始终使用括号 \u0026#34;arrow-parens\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;always\u0026#34;], // 大括号与代码不在同一行 \u0026#34;brace-style\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;1tbs\u0026#34;, { \u0026#34;allowSingleLine\u0026#34;: true }], // 多行末尾逗号 \u0026#34;comma-dangle\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;always-multiline\u0026#34;], // 逗号前后的空格 \u0026#34;comma-spacing\u0026#34;: \u0026#34;error\u0026#34;, // 缩进为2个空格，switch case的缩进为1个空格 \u0026#34;indent\u0026#34;: [\u0026#34;error\u0026#34;, 2, { \u0026#34;SwitchCase\u0026#34;: 1 }], // 在JSX中使用双引号 \u0026#34;jsx-quotes\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;prefer-double\u0026#34;], // 使用双引号 \u0026#34;quotes\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;double\u0026#34;], // 使用分号 \u0026#34;semi\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;always\u0026#34;], // 大括号内始终有空格 \u0026#34;object-curly-spacing\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;always\u0026#34;], // 对象属性引号根据需要添加 \u0026#34;quote-props\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;as-needed\u0026#34;], // 函数圆括号前不添加空格 \u0026#34;space-before-function-paren\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;never\u0026#34;], // 最大行长度为80个字符 \u0026#34;max-len\u0026#34;: [\u0026#34;error\u0026#34;, { \u0026#34;code\u0026#34;: 80 }] } Regex Previewer # 插件 txt 复制 1 2 正则表达式测试 在js文件中输入正则表达式按下 Ctrl+Alt+M` 即可快速测试 Turbo Console Log # 插件 txt 复制 1 在变量上按下 Ctrl+Alt+L` 快速添加 console.log 代码 Path Intellisense # 插件 txt 复制 1 自动完成路径文件名 Vue - Official # 插件 txt 复制 1 Vue 支持 Web # Live Server # 插件 txt 复制 1 启动具有静态和动态页面实时重新加载功能的开发本地服务器 Thunder Client # 插件 txt 复制 1 API 客户端 格式化扩展 # Prettier # 插件 官网 txt 复制 1 支持 JavaScript · TypeScript · Flow · JSX · JSON · CSS · SCSS · Less · HTML · Vue · Angular HANDLEBARS · Ember · Glimmer · GraphQL · Markdown · YAML 代码格式化 常用规则 json 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // ps: 以下规则可在 .prettierrc.json 文件中配置,在 prettierrc 中时不能有注释 { // 是否始终在箭头函数的参数周围使用括号 \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34;, // 是否大括号与代码在同一行上 \u0026#34;bracketSameLine\u0026#34;: false, // 是否在大括号内添加空格 \u0026#34;bracketSpacing\u0026#34;: true, // 是否使用分号作为语句结束符 \u0026#34;semi\u0026#34;: true, // 是否启用实验性的三元运算符格式化 \u0026#34;experimentalTernaries\u0026#34;: false, // 是否使用单引号 \u0026#34;singleQuote\u0026#34;: false, // 在JSX中是否使用单引号 \u0026#34;jsxSingleQuote\u0026#34;: false, // 对象属性是否需要引号 \u0026#34;quoteProps\u0026#34;: \u0026#34;as-needed\u0026#34;, // 是否在多行对象、数组末尾添加逗号 \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, // 是否将JSX元素的每个属性放在单独的行上 \u0026#34;singleAttributePerLine\u0026#34;: false, // HTML空白符的敏感度 \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;css\u0026#34;, // 是否在Vue文件中缩进脚本和样式 \u0026#34;vueIndentScriptAndStyle\u0026#34;: false, // 是否在Markdown文件中保留文本换行符 \u0026#34;proseWrap\u0026#34;: \u0026#34;preserve\u0026#34;, // 是否在文件开头插入格式化的特殊字符串以启用格式化 \u0026#34;insertPragma\u0026#34;: false, // 每行代码的最大字符数 \u0026#34;printWidth\u0026#34;: 80, // 是否要求格式化的文件包含特殊的格式化字符串才会被格式化 \u0026#34;requirePragma\u0026#34;: false, // 制表符的宽度 \u0026#34;tabWidth\u0026#34;: 2, // 是否使用制表符而不是空格进行缩进 \u0026#34;useTabs\u0026#34;: false, // 嵌入式语言的格式化方式 \u0026#34;embeddedLanguageFormatting\u0026#34;: \u0026#34;auto\u0026#34; } Ai 扩展 # Fitten Code # 插件 txt 复制 1 AI 代码助手 Hugo 扩展 # Hugo Snippets # 插件 txt 复制 1 2 Hugo 代码片段 使用时键入 h- 即可ktivai 代码片段 Hugo Themer # 插件 txt 复制 1 2 鼠标悬停在 partial 或 partialCached 引用上时，显示引用的部分文件的完整路径 按 F12 跳转到引用的部分文件 ","permalink":"https://linlccc.com/pending/vscodeextensions/","summary":"基础扩展 # Chinese (Simplified) # 插件 txt 复制 1 VS Code 的中文（简体）语言包 vscode-icons # 插件 txt 复制 1 图标 XML，Json，TOML 扩展 # JSON Crack # 插件 txt 复制 1 Json 数据可视化 Even Better TOML","title":"VsCode 常用扩展推荐"},{"content":" axios.ts # ts 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import axios from \u0026#34;axios\u0026#34;; // 文档：https://github.com/axios/axios#request-config // axios 全局默认配置 // axios.defaults.baseURL = process.env.baseURL || process.env.apiUrl || \u0026#39;https://api.apiopen.top/\u0026#39;;//设置默认请求路径 // axios.defaults.headers.common[\u0026#39;Authorization\u0026#39;] = AUTH_TOKEN; // axios.defaults.headers.post[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/x-www-form-urlencoded\u0026#39;; // 自定义实例配置 const config = { // baseURL: process.env.baseURL || process.env.apiUrl || \u0026#39;https://api.apiopen.top/\u0026#39; // timeout: 60 * 1000, // 超时 // withCredentials: true, // 检查跨域访问控制 }; axios.create(config); // 添加请求拦截器 axios.interceptors.request.use( (config) =\u0026gt; { console.log(\u0026#34;请求全局拦截\u0026#34;); // 请求之前处理 return config; }, (error) =\u0026gt; { // 处理请求错误 return Promise.reject(error); }, ); // 添加响应拦截器 axios.interceptors.response.use( (response) =\u0026gt; { // 处理响应数据 return response; }, (error) =\u0026gt; { // 处理响应错误 return Promise.reject(error); }, ); export { axios }; export default (app: any) =\u0026gt; { app.config.globalProperties.$axios = axios; }; main.ts # ts 复制 1 2 3 4 5 // 导入封装的axios import installAxios from \u0026#34;./axios\u0026#34;; const app = createApp(App); installAxios(app); // 使用axios api.ts # 使用 axios 制定接口函数 ts 复制 1 2 3 4 5 6 7 8 9 10 11 // 导入封装的axios import { axios } from \u0026#34;./axios\u0026#34;; // 调用接口1 export const api1 = async (params: any) =\u0026gt; { return axios.get(\u0026#34;/api/api1\u0026#34;, { params: params }); }; export const api2 = async (params: any) =\u0026gt; { return axios.post(\u0026#34;/api/api2\u0026#34;, { params: params }); }; test.vue # 调用接口 ts 复制 1 2 3 4 // 导入api import { api1 } from \u0026#34;./api\u0026#34;; api1(params).then((res) =\u0026gt; console.log(res)); ","permalink":"https://linlccc.com/posts/axiosinvue/","summary":"axios.ts # ts 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import axios from \u0026#34;axios\u0026#34;; // 文档：https://g","title":"在 Vue 中使用 Axios"},{"content":" ES6 20 个经常使用的技巧 # 打乱数组顺序 # js 复制 1 2 3 4 let arr = [\u0026#34;😄\u0026#34;, 67, true, false, \u0026#34;55\u0026#34;]; arr = arr.sort(() =\u0026gt; 0.5 - Math.random()); console.log(arr); // [ \u0026#39;😄\u0026#39;, \u0026#39;55\u0026#39;, 67, false, true ] 删除数字之外的所有字符 # js 复制 1 2 3 4 const str = \u0026#34;xieyezi 23213 is 95994 so hansome 223333\u0026#34;; const numbers = str.replace(/\\D/g, \u0026#34;\u0026#34;); console.log(numbers); // 2321395994223333 反转字符串或者单词 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 const sentence = \u0026#34;xieyezi js so handsome, lol.\u0026#34;; const reverseSentence = reverseBySeparator(sentence, \u0026#34;\u0026#34;); console.log(reverseSentence); // .lol ,emosdnah os sj izeyeix const reverseEachWord = reverseBySeparator(reverseSentence, \u0026#34; \u0026#34;); console.log(reverseEachWord); // izeyeix sj os ,emosdnah .lol function reverseBySeparator(string, separator) { return string.split(separator).reverse().join(separator); } 将十进制转换为二进制文件或十六进制数 # js 复制 1 2 3 const num = 45; num.toString(2); num.tostring(16); 合并多个对象 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const city = { name: \u0026#34;Chongqing\u0026#34;, population: \u0026#34;1,234,567,890\u0026#34;, }; const location = { longitude: \u0026#34;116.4\u0026#34;, latitude: \u0026#34;39.9\u0026#34;, }; const fullCity = { ...city, ...location }; console.log(fullCity); // { // name: \u0026#39;Chongqing\u0026#39;, // population: \u0026#39;1,234,567,890\u0026#39;, // longitude: \u0026#39;116.4\u0026#39;, // latitude: \u0026#39;39.9\u0026#39; // } === 和 == 的区别 # js 复制 1 2 3 4 5 6 7 8 9 // == -\u0026gt; 类型转换 (浅比较) // === -\u0026gt; 无类型转换 (严格比较) 0 == false; // true 0 === false; // false 1 == \u0026#34;1\u0026#34;; // true 1 === \u0026#34;1\u0026#34;; // false null == undefined; // true null === undefined; // false 解构赋值 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const forest = { location: \u0026#34;Sweden\u0026#34;, animals: 3, animalsTypes: [\u0026#34;Lions\u0026#34;, \u0026#34;Tigers\u0026#34;, \u0026#34;Bears\u0026#34;], }; const { location, animals, animalsTypes } = forest; const [lions, tigers, bears] = animalsTypes; console.log(location); // Sweden console.log(animals); // 3 console.log(lions); // Lions console.log(tigers); // Tigers console.log(bears); // Bears 交换变量的值 # js 复制 1 2 3 4 let bears = \u0026#34;bears\u0026#34;; let tigers = (\u0026#34;tigers\u0026#34;[(bears, tigers)] = [tigers, bears]); console.log(bears); // tigers console.log(tribes); // bears 判断回文字符串 # js 复制 1 2 3 4 5 6 const isRevervse = (str1, str2) =\u0026gt; { const normalize = (str) =\u0026gt; str.toLowerCase().normalize(\u0026#34;NFD\u0026#34;).split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;); return normalize(str1) === str2; }; console.log(isRevervse(\u0026#34;anagram\u0026#34;, \u0026#34;margana\u0026#34;)); // true console.log(isRevervse(\u0026#34;rac\u0026#34;, \u0026#34;car\u0026#34;)); // true 回文字符串: 正着写和反着写都一样的字符串 (特别感谢 @浮生阁阁主 勘误)\n判断两个字符串是否为互相排列 # js 复制 1 2 3 4 5 6 7 const isAnagram = (str1, str2) =\u0026gt; { const normalize = (str) =\u0026gt; str.toLowerCase().normalize(\u0026#34;NFD\u0026#34;).split(\u0026#34;\u0026#34;).sort().join(\u0026#34;\u0026#34;); return normalize(str1) === normalize(str2); }; console.log(isAnagram(\u0026#34;anagram\u0026#34;, \u0026#34;nagaram\u0026#34;)); // true console.log(isAnagram(\u0026#34;rat\u0026#34;, \u0026#34;car\u0026#34;)); // false console.log(isAnagram(\u0026#34;heArT\u0026#34;, \u0026#34;traEH\u0026#34;)); // true 判断两个字符串是否为互相排列: 给定两个字符串,一个是否是另一个的排列\n可选链操作符 # js 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 const player = { name: \u0026#34;xieyezi\u0026#34;, rating: 1000, click: () =\u0026gt; { return \u0026#34;click\u0026#34;; }, pass: (teammate) =\u0026gt; { return `Pass to ${teammate}`; }, }; console.log(player?.name); // xieyezi console.log(player?.click?.()); // click console.log(player?.teammate?.()); // undefined 三目运算符 # js 复制 1 2 3 4 // condition ? expression if true : expression if false const oxygen = 10; const diver = oxygen \u0026lt; 10 ? \u0026#34;Low oxygen\u0026#34; : \u0026#34;High oxygen\u0026#34;; console.log(diver); // High oxygen 从数组中随机选择一个值 # js 复制 1 2 3 4 const elements = [24, \u0026#34;You\u0026#34;, 777, \u0026#34;breaking\u0026#34;, 99, \u0026#34;full\u0026#34;]; const random = (arr) =\u0026gt; arr[Math.floor(Math.random() * arr.length)]; const randomElement = random(elements); console.log(randomElement); // 777 冻结对象 # js 复制 1 2 3 4 5 6 7 const octopus = { tentacles: 8, color: \u0026#34;blue\u0026#34;, }; Object.freeze(octopus); octopus.tentacles = 10; // Error, 不会改变 console.log(octopus); // { tentacles: 8, color: \u0026#39;blue\u0026#39;} 删除数组重复的元素 # js 复制 1 2 3 4 const animals = [\u0026#34;bears\u0026#34;, \u0026#34;lions\u0026#34;, \u0026#34;tigers\u0026#34;, \u0026#34;bears\u0026#34;, \u0026#34;lions\u0026#34;]; const unique = (arr) =\u0026gt; [...new Set(arr)]; console.log(unique(animals)); // [ \u0026#39;bears\u0026#39;, \u0026#39;lions\u0026#39;, \u0026#39;tigers\u0026#39; ] 保留指定位小数 # js 复制 1 2 3 4 5 6 const num = 0.123456789; const fixed2 = num.toFixed(2); const fixed3 = num.toFixed(3); console.log(fixed2); // 0.12 console.log(fixed3); // 0.123 清空数组 # js 复制 1 2 3 4 const numbers = [1, 2, 3, 4, 5]; numbers.length = 0; console.log(numbers); // [] 从 RGB 转换为 HEX # js 复制 1 2 3 4 5 6 7 8 const rgbToHex = (r, g, b) =\u0026gt; { const toHex = (num) =\u0026gt; { const hex = num.toString(16); return hex.length === 1 ? `0${hex}` : hex; }; return `#${toHex(r)}${toHex(g)}${toHex(b)}`; }; console.log(rgbToHex(46, 32, 67)); // #2e2043 从数组中获取最大值和最小值 # js 复制 1 2 3 4 5 const nums = [1, 2, 3, 4, 5, -3, 99, -45, -1]; const max = Math.max(...nums); const min = Math.min(...nums); console.log(max); // 99 console.log(min); // -45 空值合并运算符 # js 复制 1 2 3 4 5 6 7 8 9 10 11 const nullval = null cost emptyString = \u0026#39;\u0026#39; const someNum = 13 const a = nullval ?? \u0026#39;A default\u0026#39; const b = emptyString ?? \u0026#39;B default\u0026#39; const c = SomeNum ?? \u0026#39;C default\u0026#39; console.log(a) // A default console.log(b) // \u0026#39;\u0026#39; // empty string != undefined or null console.log(c) // 13 过滤数组中值为 false 的值 # js 复制 1 2 3 const nums = [1, 0, undefined, null, false]; const truthyNums = nums.filter(Boolean); console.log(truthyNums); // [1] ","permalink":"https://linlccc.com/pending/commonlyusedes6/","summary":"ES6 20 个经常使用的技巧 # 打乱数组顺序 # js 复制 1 2 3 4 let arr = [\u0026#34;😄\u0026#34;, 67, true, false, \u0026#34;55\u0026#34;]; arr = arr.sort(() =\u0026gt; 0.5 - Math.random()); console.log(arr); // [ \u0026#39;😄\u0026#39;, \u0026#39;55\u0026#39;, 67, false,","title":"ES6 常用代码块"},{"content":" 具体配置可见 # NGINX 配置\nNGINX 入门学习笔记\nNGINX 备忘清单\nWeb 服务器 # nginx 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # http server { listen 80; server_name _; location / { root /data; index index.html index.htm; } } # https server { listen 443 ssl; server_name _; ssl_certificate /path/to/certificete.crt; ssl_certificate_key /path/to/private-key.key; location / { root /data; index index.html index.htm; } } 反向代理 # nginx 复制 1 2 3 4 5 6 7 8 9 server { listen 80; server_name _; location / { proxy_pass http://192.168.241.11; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } 负载均衡 # nginx 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 upstream web { ip_hash #会话保持 server 192.168.241.22; server 192.168.241.23; } server { listen 80; server_name _; location / { proxy_pass http://web; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } 重定向 # nginx 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 老域名跳转新域名 server { listen 80; server_name old.cxk.cn; location / { rewrite ^/(.*)$ https://new.cxk.cn/$1; } } # 路径重定向 server { listen 80; server_name old.cxk.cn; location / { rewrite ^/old.cxk.cn/(.*)$ /new-path/$1; } } 防盗链 # nginx 复制 1 2 3 4 5 6 7 8 9 10 server { listen 80; server_name _; location ~* \\.(gif|jpg|jpeg|png) { valid_referers none blocked *.cxk.cn; if ($invalid_referer) { return 403; } } } 手机端重定向 PC # nginx 复制 1 2 3 4 5 6 7 8 9 server { listen 80; server_name _; location / { if ($http_user_agent ~* \u0026#39;(android|iphone|ipad)\u0026#39;) { return ^/(.*)$ https://yd.cxk.cn/$1; } } } 基于请求路径转发不同服务 # nginx 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 80; server_name _; location / { proxy_pass http://192.168.241.11; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; } location /beijing { proxy_pass http://192.168.241.22; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; } location /nanjing { proxy_pass http://192.168.241.23; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; } } ","permalink":"https://linlccc.com/pending/nginxconfig/","summary":"具体配置可见 # NGINX 配置 NGINX 入门学习笔记 NGINX 备忘清单 Web 服务器 # nginx 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # http server { listen 80; server_name _; location / { root /data; index index.html index.htm; } } #","title":"Nginx基础配置"},{"content":" DCL(Data Control Language)数据控制语言 # DCL 在 mysql 中可以正常使用其他数据库没测试 用户管理 # sql 复制 1 2 3 4 5 6 -- 查询用户 select host,user from mysql.user; -- 添加用户 create user \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; identified by \u0026#39;密码\u0026#39;; -- 删除用户 drop user \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; 权限管理 # sql 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 查询权限 show grants for \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; -- 查询 root 用户权限 show grants for \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; -- 给予权限 grant 权限列表 on 库名.表名 to \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; -- 给 user1 授予所有权限 grant all on *.* to \u0026#39;user1\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 revoke 权限列表 on 库名.表名 from \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; -- 撤销 user1 的所有权限 revoke all on *.* from \u0026#39;user1\u0026#39;@\u0026#39;localhost\u0026#39;; DDL(Data Definition Language)数据定义语言 # 操作库 # sql 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 查看所有数据库 show databases; -- 查看数据库的定义信息 show create database 库名; -- 创建库 create database 库名; -- 检查库是否存在，不存在则创建 create database if not exists 库名; -- 修改数据库字符信息 alter database 库名 character set utf8; -- 删除数据库 drop database 库名; 操作表 # sql 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- 查看表结构 desc 表名; -- 查看创建表的SQL语句 show create table 表名; -- 创建表 create table 表名( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); -- 修改表名 alter table 旧表名 rename to 新表名; -- 删除表 drop table 表名; -- 检查表是否存在，存在则删除 drop table if exists 表名; -- 添加一列 alter table 表名 add 列名 数据类型; -- 删除列 alter table 表名 drop 列名; DML(Data Manipulation Language)数据操作语言 # 插入 insert into # sql 复制 1 2 3 4 -- 写列名 insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); -- 不写列名 insert into 表名 values(值1,值2,...值n); 删除 delete # sql 复制 1 2 3 4 5 6 -- 删除表中数据 delete from 表名 where 列名 = 值; -- 删除表中所有数据 delete from 表名; -- 删除表中所有数据（直接删除表，再创建一张一样的表） truncate table 表名; 修改 update # sql 复制 1 2 3 4 -- 不带条件的修改(修改所有行) update 表名 set 列名 = 值; -- 带条件的修改 update 表名 set 列名 = 值 where 列名 = 值; DQL(Data Query Language)数据查询语言 # 基础关键字 # sql 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 -- 查询年龄大于等于20 小于等于30 -- \u0026amp;\u0026amp;(并且) select * from 表名 where age \u0026gt;= 20 \u0026amp;\u0026amp; age \u0026lt;= 30; -- and(并且) select * from 表名 where age \u0026gt;= 20 and age \u0026lt;= 30; -- between..and(之间) select * from 表名 where age between 20 and 30; -- 查询年龄22岁，18岁，25岁的信息 -- or(或者) select * from 表名 where age = 22 or age = 18 or age = 25; -- in(集合) select * from 表名 where age in (22,18,25); -- 查询英语成绩不为null -- in not null(不为空) select * from 表名 where english is not null; /** like(模糊查询) _(单个字符) %(多个字符) */ -- 查询性王的人 select * from 表名 where name like \u0026#39;王%\u0026#39;; -- 查询第二个字是麻的人 select * from 表名 where name like \u0026#39;_麻%\u0026#39;; -- 查询名字是三个字的人 select * from 表名 where name like \u0026#39;___\u0026#39;; -- distinct(重复的值都只显示一个) -- 查询年龄集合，重复的只显示一个 select distinct age where 表名; 排序查询 # sql 复制 1 2 3 4 -- 根据年龄升序(默认) select * from 表名 order by age; -- 根据年龄降序 select * from 表名 order by age desc; 聚合函数 # sql 复制 1 2 3 4 5 6 7 8 9 10 -- 计算数据行数 select max(*) from 表名; -- 计算年龄最大是多少 select max(age) from 表名; -- 计算年龄最小是多少 select min(age) from 表名; -- 计算年龄总和是多少 select sum(age) from 表名; -- 计算年龄平均数是多少 select avg(age) from 表名; 分组查询 group by # sql 复制 1 2 3 4 5 6 -- 按照性别分组,分别查询男、女的平均分、人数 select sex,avg(math),count(id) from 表名 group by sex; -- 将分数高于60的人按照性别分组,分别查询男、女的平均分、人数 select sex,avg(math),count(id) from 表名 where math \u0026gt; 60 group by sex; -- 按照性别分组,分别查询男、女的平均分、人数。要求：分数大于60，分组后人数大于2 select sex,avg(math),count(id) from 表名 where math \u0026gt; 60 group by sex having count(id) \u0026gt; 2; 分页查询 # sql 复制 1 2 3 4 5 6 7 8 9 10 11 12 /** 该分页只支持mysql limit 开始索引,查询条数 开始索引计算公式：(页数 - 1) * 每页条数 */ -- 每页显示10条 -- 第一页 select * from 表名 limit 0,10; -- 第二页 select * from 表名 limit 10,10; -- 第三页 select * from 表名 limit 20,10; 内连接查询 # sql 复制 1 2 3 4 5 6 7 8 9 10 11 -- 隐式内连接 -- 语法 select 字段列表 from 表1,表2...表n where 条件; -- 例子 select t1.c1,t1.c2,t2.c1 from t1,t2 where t1.t2Id = t2.id; -- 显式内连接 -- 语法 select 字段列表 from 表1 join 表2 on 条件; -- 例子 select * from t1 join t2 on t1.t2Id = t2.id; 外连接查询 # sql 复制 1 2 3 4 5 6 7 8 9 10 11 -- 左外连接 -- 语法 select 字段列表 from 表1 left join 表2 on 条件; -- 例子 select t1.*,t2.c1 from t1 left join t2 ON t1.t2Id = t2.id; -- 右外连接 -- 语法 select 字段列表 from 表1 right join 表2 on 条件; -- 例子 select t1.*,t2.c1 from t1 right join t2 ON t1.t2Id = t2.id; 子查询 # 子查询结果是单行单列 # sql 复制 1 2 3 4 5 6 -- 查询最高的成绩（这里假设最高为98） select max(math) from 表名; -- 查询成绩最高的人的信息 select * from 表名 where math = 98; -- 使用子查询 select * from 表名 where math = (select max(math) from 表名); 子查询结果是多行单列 # sql 复制 1 2 3 4 5 6 -- 查询名称为n1或者n2的id（这里假设id为1，2） select id from 表名 where name = \u0026#39;n1\u0026#39; or name = \u0026#39;n2\u0026#39;; -- 查询成绩最高的人的信息 select * from 表名 where id = 1 or id = 2; -- 使用子查询 select * from 表名 where id in (select id from 表名 where name = \u0026#39;n1\u0026#39; or name = \u0026#39;n2\u0026#39;); 子查询结果是多行多列 # sql 复制 1 2 -- 这里t1和t2是同一张表，查询结果每列有两个相同的数据 select * from 表名 t1,(select * from 表名) t2 where t1.id = t2.id; ","permalink":"https://linlccc.com/posts/commonsql/","summary":"DCL(Data Control Language)数据控制语言 # DCL 在 mysql 中可以正常使用其他数据库没测试 用户管理 # sql 复制 1 2 3 4 5 6 -- 查询用户 select host,user from mysql.user; -- 添加用户 create user \u0026#39","title":"常用SQL"},{"content":" 系统指令 # Bash 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 显示系统信息：内核版本、机器类型等 uname # 显示正在运行的Linux内核的发行版本 uname -r # 显示当前时间、系统运行时间、用户和负载平均值 uptime # 显示系统主机名 hostname # 显示当前主机的ip地址 hostname -i # 查看系统最近一次的重启时间以及重启之前的系统登录信息 last reboot # 显示当前日期和时间 date # 设置系统时间与日期 timedatectl # 快速查看当前/指定年份日历 cal # 显示目前登入系统的用户信息 w # 显示当前用户的用户名 whoami # 显示名为\u0026#34;username\u0026#34;的用户的信息 finger username 文件命令 # Bash 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 以长格式列出所有文件的详细信息 ls -al # 显示当前工作目录的路径 pwd # 创建一个名为 dir1 的新目录 mkdir dir1 # 删除名为 file1 的文件 rm file1 # 强制删除名为 file2 的文件 rm -f file2 # 递归删除目录 dir1 及其内容 rm -r dir1 # 强制删除目录 dir1 及其内容 rm -rf dir1 # 复制 file1,创建或覆盖 file2 cp file1 file2 # 将 dir1 复制到 dir2,包括子目录 cp -r dir1 dir2 # 将 file1 重命名或移动到 file2 mv file1 file2 # 创建名为 linkName 到 fileName 的符号链接 ln -s /oath/to/fileName linkName # 创建一个名为 file1 的空文件 touch file1 # 创建/覆盖 file1,等得标准输入 cat \u0026gt; file1 # 逐页显示们 file1 的内容 more file1 # 显示 file1 的前十行 head file1 # 显示 file1 的最后十行 tail file1 # 使用对称密码对 file1 进行加密,需要提供密码短语 gpg -c file1 # 解密 file2.gpg,提示输入密码 gpg file2.gpg # 统计文件中的字数、行数和字符数 wc # 使用管道或文件提供的参数执行命令 xargs 用户管理 # Bash 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 显示用户的UID、GID、组 id # 显示最后登录用户的列表 last # 显示当前登录的用户 who # 创建一个名为 Admin 的新用户组 groupadd admin # 创建一个名为 Sam 的新用户组 adduser Sam # 删除名为 Sam 的用户 userdel Sam # 修改现有用户的属性 usermod 硬件 # Bash 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 内核会将开机过程信息存储在环形缓冲区中 dmesg # 显示 CPU 的详细信息 cat/proc/cpuinfo # 显示详细的系统内存使用信息 cat/proc/meminfo # 列出系统的详细硬件配置 lshw # 列出所有可用的块设备的信息 lsblk # 显示系统内存使用情况 free -m # 以树状格式详细显示 PCI 设备信息 lspci -tv # 以树状格式详细显示 USB 设备信息 lsusb -tv # 显示系统 BIOS 中的硬件信息 dmidecode # 显示磁盘 /dev/sda 的信息 hdparm -i /dev/sda # 用于检查设备 /dev/sda 是否存在坏块,并显示检测进度 badblocks -s /dev/sda 登录 # Bash 复制 1 2 3 4 5 6 7 8 # 向指定主机名发起 SSH 连接 ssh user@hostname # 使用特定端口发起 SSH 连接 ssh -p portNumber user@hostname # 通过 telnet 连接到主机的默认端口 23 Connect to the host via telnet default port 23 # 通过l elnet 默认端口23连接到主机 telnet host 安装包 # Bash 复制 1 2 3 4 5 6 7 8 # 使用 RPM 包管理器安装 pkgName.rpm 包 rpm -i pkgName.rpm # 卸载指定的 RPM 包 rpm -e pkgName # 使用 DNF 安装指定的包， dnf install pkgName # 使用 Pacman 安装指定的包 pacman -S 安装源（编译） # Bash 复制 1 2 3 4 5 6 # 检查系统兼容性并生成用于软件安装的 makefile ./configure # 按照 makefoile 中的指令编译代码 make # 将编译后的代码安装到指定的系统位置 make install 目录遍历 # Bash 复制 1 2 3 4 5 6 # 切换到父目录 cd .. # 将当前目录更改为用户的主目录 cd # 将当前目录更改为\u0026#34;/mnt\u0026#34; cd /mnt 流程相关 # Bash 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 显示当前进程的快照 ps # 显示运行中的 tolnet 进程的详细信息 ps aux | grep telnet # 显示进程的内存映射 pmap # 显示运行任务的动态实时视图 top # 终止具有 PID 1234 的进程 kill 1234 # 终止所有名为\u0026#39;proc\u0026#39; 的进程 killall proc # 终止具有指定名称的进程 pkill processName # 在后台恢复暂停的作业 bg # 将暂停的作业带到前台 fg # 将作业编号为\u0026#39;n\u0026#39; 的作业移到前台运行 fg n # 列出所有打开的文件和进程 lsof # 更改具有给定 PID 的进程的优先级 renice 19 PID # 显示firefox 进程的进程ID pgrep firefox # 显示运行中的进程树 pstree 网络 # Bash 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 显示所有网络接口及其信息 ip addr show # 将 IP 地址 192.168.0.1 分配给eth0接口 ip address add 192.168.0.1/24 dev eth0 # 显示网络接口及其配置 ifconfig # 发送 ICMP 数据包,测量与 host 之问的往返时间 ping host # 检索并显示域名的注册信息 whois domain # 查询 DNS,提供域名的 DNS 信息 dig domain # 将 IP 地址解析为主机名,显示 DNS 信息 dig -x host # 对域名进行 IP 查找 host gexample.com # 从指定路径下载文件 wget flePath # 显示各种与网络相关的信息和统计数据 netstat 磁盘使用情况 # Bash 复制 1 2 3 4 5 6 7 8 9 10 11 12 # 显示所有已挂载文件系统可读的磁盘空问使用情况 df -h # 显示所有已挂载文件系统的 inode 使用情况 df -i # 列出所有驱动器上的分区及其信息 fdisk -l # 显示 /dir1 目录的总磁盘使用大小的摘要,以可读方式呈现 du -sh/dir1 # 显示所有已挂载文件系统及其属性的列表 findmnt # 将设备挂载到指定的文件系统挂载点上 mount devicePath mountPoint 压缩/存档 # Bash 复制 1 2 3 4 5 6 7 8 # 创建一个名为 backup.tar 的 tar 归档文件,其中包含 /home/ubuntu 目录的内容 tar -cf backup.tar/home/ubuntu # 从 backup.tar 归档文件中提取文件 tar -xf backup.tar # 创建一个名为 backup.tar.gz 的压缩 tar 归档文件,其中包含 /home/ubuntu 目录的内容 tar -zcvf backup.tar.gz/home/ubuntu # 将文件 file1 压缩为 file1.gz,并删除原始文件 gzip file1 日志文件传输 # Bash 复制 1 2 3 4 5 6 # 将们 file.txt 复制到远程主机的指定目录 scp file.txt remoteuser@remoteHost:/remote/diroctory # 将源目录的内容同步到目标目录,保留属性 rsync -a /home/ubuntu/backup/ # 同步本地目录到远程,保留属性 rsync -a /var/www/web/user@remoteHost:/backup/webBackup/ 搜索 # Bash 复制 1 2 3 4 5 6 7 8 9 10 # 在文件中搜索给定的模式 grep pattern file # 在 dir1 目录及其子目录中递归搜索指定的 pattern grep -r pattern dir1 # 使用预建的数据库查找名为 file 的文件 locate file # 递归搜索 /home 目录中名为 index 的文件 find /homeName index # 在 /home 目录中查找大小超过 10000k 的文件 find /homeSize +10000k 文件权限 # Bash 复制 1 2 3 4 5 6 7 8 # 设置文件/data的权限为所有者读/写,组和其他人只读 chmod 644 /data/ # 将目录 /dir1 的权限设置为对所有者可读可写/可执行,对组和其他用户可读/可执行 chmod 755 /dir1 # 将文件 filename 的所有者更改为 bob 并将所属组更改为 devops chown bob:devops filename # 更改目录的所有者和所属组 chown ownername ","permalink":"https://linlccc.com/pending/linuxcommandlist/","summary":"系统指令 # Bash 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 显示系统信息：内核版本、机器类型等 uname # 显示正在运行的Linux内核的发行版","title":"Linux 命令大全"},{"content":" 生成新的 SSH 密钥 # 在终端中输入以下指令以提供的电子邮件为标签创建SSH密钥 Bash 复制 1 ssh-keygen -t rsa -b 4096 -C \u0026#34;[email@example.com]\u0026#34; 根据提示输入密钥保存文件，可空保存到默认文件C:\\Users\\[User]\\.ssh\\id_rsa 根据提示输入两次密码（建议不设置密码，否者每次 push 都需要输入密码） 将 SSH 密钥添加到 ssh-agent # 以管理员权限打开 PowerShell 启动 ssh agent: Bash 复制 1 2 Get-Service -Name ssh-agent | Set-Service -StartupType Manual Start-Service ssh-agent 将 SSH 私钥添加到 ssh-agent (无需管理员权限) Bash 复制 1 ssh-add C:\\Users\\[User]\\.ssh\\id_rsa 移除 SSH 密钥 # 删除C:\\Users\\[User]\\.ssh\\文件夹中的两个密钥文件 从ssh agent中移除ssh密钥 Bash 复制 1 2 3 4 # 查看已加载的密钥列表 ssh-add -l # 移除密钥 ssh-add -d C:\\Users\\[User]\\.ssh\\id_rsa ","permalink":"https://linlccc.com/posts/managessh/","summary":"生成新的 SSH 密钥 # 在终端中输入以下指令以提供的电子邮件为标签创建SSH密钥 Bash 复制 1 ssh-keygen -t rsa -b 4096 -C \u0026#34;[email@example.com]\u0026#34; 根据提示输入密钥保存文件，可空保存到默认文件C","title":"管理 SSH"},{"content":" 基础 # 整数类型 # 这些类型里面除了只有 signed 和 int 的都可以省略 signed / int\n例如 short, short int, signed short, signed short int 表示一个类型\n类型 占用字节数 取值范围 signed char 1 -128 到 127 unsigned char 1 0 到 255 short, short int, signed short, signed short int 2 -32768 到 32767 unsigned short, unsigned short int 2 0 到 65535 int, signed, signed int 4 -2147483648 到 2147483647 unsigned, unsigned int 4 0 到 4294967295 long, long int, signed long, signed long int 4 与 int 或 long long 相同 unsigned long, unsigned long int 4 与 unsigned 或 unsigned long long 相同 long long, long long int, signed long long, signed long long int 8 -9223372036854775808 到 9223372036854775807 unsigned long long, unsigned long long int 8 0 到 18446744073709551615 浮点类型 # 类型 占用字节数 取值范围 float 4 1.175494351e-38 到 3.402823466e+38 double 8 2.2250738585072014e-308 到 1.7976931348623157e+308 long double 12 3.36210314311209350626267781732175260e-4932 到 1.18973149535723176508575932662800702e+4932 无效浮点数信息 # 在 C++中，浮点数类型的值可以是无效的，具体取决于浮点数类型的规范。以下是一些常见的无效浮点数值：\nNaN (Not a Number): 表示无效的计算结果，例如 0.0 / 0.0、sqrt(-1) 等，它可以用 std::numeric_limits\u0026lt;T\u0026gt;::quiet_NaN() 来表示。 Inf (Infinity): 表示除以 0 或者取 log(0) 等无穷值的结果，它可以用 std::numeric_limits\u0026lt;T\u0026gt;::infinity() 来表示。 -Inf (Negative Infinity): 表示除以 -0 或者取 log(-0) 等负无穷值的结果，它可以用 -std::numeric_limits\u0026lt;T\u0026gt;::infinity() 来表示。 denormalized number: 非规格化数，它是一个非零的非规格化浮点数 W，不同于规格化数它的指数部分全是 0。在一些平台上，它可能会被截断成 0。 在 C++ 标准库中，可以使用 std::numeric_limits\u0026lt;T\u0026gt; 类模板来获取特定浮点数类型 T 的限制信息，例如 std::numeric_limits\u0026lt;double\u0026gt;::quiet_NaN() 就可以得到 double 类型的 NaN。\n无效浮点数操作 # 操作 结果 ±value/0 ±Infinity ±Infinity ± value ±Infinity ±Infinity * value ±Infinity ±Infinity / value ±Infinity 0 / 0 NaN ±Infinity / ±Infinity NaN Infinity - Infinity NaN Infinity * 0 NaN 数字字面量 # 类型 示例 int 42, -123 unsigned int 42u, 123U long 123456L, -123L unsigned long 123456ul, 123ul long long 123456789LL, -123LL unsigned long long 123456789ull, 123ull float 3.14f, -2.5F double 3.14, -2.5 long double 3.14L, -2.5L 进制表示方式 # 进制 表示方式 示例 二进制 以 0b 或 0B 开头 0b110 八进制 以 0 开头 017 10 进制 直接输入数字 123 16 进制 以 0x 或 0X 开头 0x1A sizeof 运算符 # sizeof(type)：获取类型 type 的大小，返回 size_t 类型的值。 sizeof expression：获取表达式 expression 的大小，返回 size_t 类型的值。 sizeof...：获取模板参数包中元素的个数，返回 size_t 类型的值。这个用法通常用于可变参数模板。 c\u0026#43;\u0026#43; 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 // 获取类型的大小 std::cout \u0026lt;\u0026lt; \u0026#34;sizeof(int): \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 获取表达式的大小 int arr[] = {1, 2, 3}; std::cout \u0026lt;\u0026lt; \u0026#34;sizeof(arr): \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 获取模板参数包中元素的个数 template\u0026lt;typename... Ts\u0026gt; void foo(Ts... args) { std::cout \u0026lt;\u0026lt; \u0026#34;sizeof...(args): \u0026#34; \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } foo(1, \u0026#39;a\u0026#39;, 3.14); // 输出 \u0026#34;sizeof...(args): 3\u0026#34; 数值的上下限 # std::numeric_limits\u0026lt;T\u0026gt; 类模板提供了获取数值类型 T 的上下限的方法\nc\u0026#43;\u0026#43; 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 在整数类型中 min 和 lowest 都是相同的，都是最小值 // 获取 int 类型的上限 std::numeric_limits\u0026lt;int\u0026gt;::max(); // 获取 int 类型的下限 std::numeric_limits\u0026lt;int\u0026gt;::min(); // 以下方法也可以获取下限 std::numeric_limits\u0026lt;int\u0026gt;::lowest(); // 在浮点数类型中，min 和 lowest 不同，min 得到的是最小的正整数，lowest 得到的才是最小的值 // 获取 float 类型的上限（3.40282e+38） std::numeric_limits\u0026lt;float\u0026gt;::max(); // 获取 float 类型的最小的正整数（1.17549e-38） std::numeric_limits\u0026lt;float\u0026gt;::min(); // 获取 float 类型的下限（-3.40282e+38） std::numeric_limits\u0026lt;float\u0026gt;::lowest(); char 、 wchar_t 、 char8_t 、 char16_t 、 char32_t # 以上几种都是原生字符类型，用于表示数字、字母、符号等字符。\nchar:\n占用一个字节（8 位） 用于表示单个 8 位字符，即 ASCII 码表中的字符，范围是 0~127 在 C++ 中使用最为广泛，可以用于表示 ANSI 编码和 UTF-8 编码的字符，建议在表示 ASCII 字符时使用。 wchar_t:\n在不同平台上占用的字节数不同，通常为 2 个字节（16 位）或 4 个字节（32 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 在处理 Unicode 字符或多语言环境下有更好的应用场景，建议在需要处理 Unicode 字符时使用。 在些跨平台代码是不建议使用，因为不同平台上的 wchar_t 占用的字节数不同。 char8_t:\n占用一个字节（8 位） 用于表示单个 8 位字符，范围是所有 Unicode 字符中的 ASCII 码表部分，即 0~127 用于表示 UTF-8 编码的字符，建议在需要处理 UTF-8 编码的字符时使用。 char16_t:\n占用两个字节（16 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 用于表示 UTF-16 编码的字符，建议在需要处理 UTF-16 编码的字符时使用。 char32_t:\n占用四个字节（32 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 用于表示 UTF-32 编码的字符，建议在需要处理 UTF-32 编码的字符时使用。 变量初始化赋值 # 在 C++中初始化赋值有三种方式\n建议平时使用花括号表示法，避免隐式类型转换，如果类型不匹配会报错，以达到更好的代码可读性和可维护性 赋值表示法和函数表示法在初始化时不会进行类型检查，如果类型不匹配会进行隐式类型转换（缩窄转换） 赋值表示法和函数表示法在进行缩窄转换时，大多数编译器会发出数据丢失的警告 c\u0026#43;\u0026#43; 复制 1 2 3 4 int i = 0; // 赋值表示法 int j(0); // 函数表示法 int k{0}; // 花括号表示法 int l{}; // 这里是默认赋值为0 显示类型转换 # 类型转换方式 示例 建议使用方式 C 风格类型转换 (float) x 不建议使用 静态/强制类型转换 static_cast\u0026lt;float\u0026gt;(x) 建议使用 重新解释类型的转换 reinterpret_cast\u0026lt;float\u0026gt;(x) 转换指针类型时建议使用 旧式的类型转换 float(x) 不建议使用 格式化字符串 std::format # std::format 是 C++20 中的新特性，它提供了一种新的字符串格式化方式。该特性可以用来将多种类型的值格式化为字符串，并且支持多种格式控制符，可以更加灵活地控制输出格式。\n这里列出格式说明符的一般形式：{[arg_id][:[[fill]align][sign][\u0026quot;#\u0026quot;][\u0026quot;0\u0026quot;][width][\u0026quot;.\u0026quot; precision][\u0026quot;L\u0026quot;][type]]}\narg_id：表示参数的索引, 从 0 开始\nfill：指定填充字符，可以是任意字符。如果省略，则默认为空格。\nc\u0026#43;\u0026#43; 复制 1 2 std::format(\u0026#34;|{:\u0026lt;10}|\u0026#34;, \u0026#34;hello\u0026#34;); // |hello | std::format(\u0026#34;|{:*\u0026lt;10}|\u0026#34;, \u0026#34;hello\u0026#34;); // |hello*****| align：指定对齐方式，可以是以下几种：\n\u0026lt;：左对齐。 \u0026gt;: 右对齐。 ^: 居中对齐。 c\u0026#43;\u0026#43; 复制 1 2 3 std::format(\u0026#34;|{:\u0026lt;10}|\u0026#34;, \u0026#34;hello\u0026#34;); // |hello | std::format(\u0026#34;|{:\u0026gt;10}|\u0026#34;, \u0026#34;hello\u0026#34;); // | hello| std::format(\u0026#34;|{:^10}|\u0026#34;, \u0026#34;hello\u0026#34;); // | hello | sign：指定符号显示方式，可以是以下几种：\n+：显示正号和负号。 -：只显示负号。 ``（空格）：在正数前面加空格，负数前面加负号（默认）。 c\u0026#43;\u0026#43; 复制 1 2 3 4 5 std::format(\u0026#34;|{:+}|\u0026#34;, 10); // |+10| std::format(\u0026#34;|{:+}|\u0026#34;, -10); // |-10| std::format(\u0026#34;|{:-}|\u0026#34;, -10); // |-10| std::format(\u0026#34;|{: }|\u0026#34;, 10); // | 10| std::format(\u0026#34;|{: }|\u0026#34;, -10); // |-10| #：指定转换类型，可以是以下几种：\nb 或 B：二进制。 o 或 O：八进制。 x 或 X：十六进制。 e 或 E：科学计数法。 f 或 F：浮点数（默认）。 g 或 G：自动选择 f 或 e。 a 或 A：十六进制浮点数。 c\u0026#43;\u0026#43; 复制 1 2 3 4 5 6 7 std::format(\u0026#34;|{:#x}|\u0026#34;, 255); // |0xff| std::format(\u0026#34;|{:#X}|\u0026#34;, 255); // |0xFF| std::format(\u0026#34;|{:#b}|\u0026#34;, 255); // |0b11111111| std::format(\u0026#34;|{:#o}|\u0026#34;, 255); // |0377| std::format(\u0026#34;|{:.2e}|\u0026#34;, 123.456); // |1.23e+02| std::format(\u0026#34;|{:.2f}|\u0026#34;, 123.456); // |123.46| std::format(\u0026#34;|{:.2g}|\u0026#34;, 123.456); // |1.2e+02| width：指定输出宽度，如果输出的字符串宽度小于指定的宽度，则会在左侧或右侧填充指定字符。\n.precision：指定浮点数输出的精度，即小数点后保留的位数\n常用转义字符 # 转义字符 含义 \\n 换行符（windows 中是\\r\\n） \\r 回车符 \\t 垂直制表符 \\v 水平制表符 \\ 反斜杠 ' 单引号 \u0026quot; 双引号 常用预处理指令 # 预处理指令 含义 #if 用于条件编译，如果条件为真，则编译后面的代码，否则跳过后面的代码 #ifdef 用于条件编译，如果宏定义了，则编译后面的代码，否则跳过后面的代码 #ifndef 用于条件编译，如果宏没有定义，则编译后面的代码，否则跳过后面的代码 #else 用于条件编译，如果条件为假，则编译后面的代码，否则跳过后面的代码 #endif 用于条件编译，结束条件编译，与 #if 配对使用 #define 用于定义宏，可以用于条件编译，也可以用于替换代码中的字符串 #undef 用于取消宏定义，与 #define 配对使用 #error 用于输出错误信息，编译时会报错 #line 用于指定行号，与 #file 配对使用 #file 用于指定文件名，与 #line 配对使用 #pragma 用于指定编译器的行为，如指定编译器忽略警告 ","permalink":"https://linlccc.com/posts/cppstudynotes/","summary":"基础 # 整数类型 # 这些类型里面除了只有 signed 和 int 的都可以省略 signed / int 例如 short, short int, signed short, signed short int 表示一个类型 类型 占用字节数 取值范围 signed char 1 -128 到 127 unsigned char 1 0 到 255 short,","title":"C++ 学习笔记"},{"content":" 正则表达式 # 1. Safari 处理正则表达式中的正向后行断言时(?\u0026lt;=\u0026hellip;)，异常 # js 复制 1 2 3 4 5 6 // 以下代码在 Chrome 中正常，但在 Safari 中会报错 \u0026#34;https://linlccc.com?theme=light\u0026#34;.replace(/(?\u0026lt;=[?|\u0026amp;]theme=)\\w+/, \u0026#34;dark\u0026#34;); // 解决方案，使用捕捉组+替换字符串的方式 \u0026#34;https://linlccc.com?theme=light\u0026#34;.replace(/([?|\u0026amp;]theme=)\\w+/, \u0026#34;$1dark\u0026#34;); // 以上两个执行结果都是 \u0026#34;https://linlccc.com?theme=dark\u0026#34; ","permalink":"https://linlccc.com/posts/saferisteppingonthepit/","summary":"正则表达式 # 1. Safari 处理正则表达式中的正向后行断言时(?\u0026lt;=\u0026hellip;)，异常 # js 复制 1 2 3 4 5 6 // 以下代码在 Chrome 中正常，但在 Safari 中会报","title":"踩坑记--Safari之正向后行断言"},{"content":" 概念 # 每一个模板都有一个名为 Page 数据对象\nPage 信息参考： Page 信息参考 基础语法 # 访问变量 # go 复制 1 2 {{ .Titel }} // 访问已存在的变量 {{ $address }} // 访问自定义变量 声明变量与赋值 # go 复制 1 2 3 4 {{ $address := \u0026#34;http://www.baidu.com\u0026#34; }} // 声明自定义变量并赋值 {{ $msg := `Line one. Line two.` }} // 支持多行字符串 {{ $msg = \u0026#34;\u0026#34; }} // 将msg的值修改为空字符串 条件语句 # 条件语句 if/with 都以 {{ end }} 结束\n在 hugo 模板中，条件语句的条件可以是任何表达式，而不仅仅是布尔类型的表达式，以下情况会被认为是 false：\n空字符串 \u0026quot;\u0026quot; 空数组 [] 空字典 map[] 空指针 nil 数值 0 布尔值 false if # 很多情况下建议使用 with 语句，而不是 if 语句，因为 with 语句可以重新绑定上下文，而 if 语句不能\ngo 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 {{ if .IsHome }} {{ end }} // 判断 IsHome 的值 {{ if eq .Title \u0026#34;Home\u0026#34; }} {{ end }} // 判断变量是否相等 {{ if ne .Title \u0026#34;Home\u0026#34; }} {{ end }} // 判断变量是否不相等 {{ if and .IsHome .Params.show }} {{ end }} // 判断多个条件是否同时满足 {{ if or .IsHome .Params.show }} {{ end }} // 判断多个条件是否有一个满足 {{ if not .IsHome }} {{ end }} // 判断条件是否不满足 {{ if strings.Contains \u0026#34;hugo\u0026#34; \u0026#34;go\u0026#34; }} {{end}} // 判断是否包含指定字符串 // 该示例和 with 的第一个示例做完全相同的事 {{ if isset .Params \u0026#34;title\u0026#34; }} \u0026lt;h4\u0026gt;{{ index .Params \u0026#34;title\u0026#34; }}\u0026lt;/h4\u0026gt; {{ end }} // 但是 if 可是使用 else if 语句 {{ if (isset .Params \u0026#34;description\u0026#34;) }} {{ index .Params \u0026#34;description\u0026#34; }} {{ else if (isset .Params \u0026#34;summary\u0026#34;) }} {{ index .Params \u0026#34;summary\u0026#34; }} {{ else }} {{ .Summary }} {{ end }} // 使用 or/and , 只要 .Params.title 或者 .Params.caption 有一个存在，并且 .Params.attr 存在，就会执行该块 {{ if (and (or (isset .Params \u0026#34;title\u0026#34;) (isset .Params \u0026#34;caption\u0026#34;)) (isset .Params \u0026#34;attr\u0026#34;)) }} \u0026lt;div class=\u0026#34;caption {{ index .Params \u0026#34;attr\u0026#34; }}\u0026#34;\u0026gt; {{ if (isset .Params \u0026#34;title\u0026#34;) }} \u0026lt;h4\u0026gt;{{ index .Params \u0026#34;title\u0026#34; }}\u0026lt;/h4\u0026gt; {{ end }} {{ if (isset .Params \u0026#34;caption\u0026#34;) }} \u0026lt;p\u0026gt;{{ index .Params \u0026#34;caption\u0026#34; }}\u0026lt;/p\u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} with # with 在其范围内重新绑定上下文.\ngo 复制 1 2 3 4 5 6 7 8 9 10 11 // 如果 .Params.title 为空，将跳过该块 {{ with .Params.title }} \u0026lt;h4\u0026gt;{{ . }}\u0026lt;/h4\u0026gt; {{ end }} // 如果 Param 设置了 description，那么输出 Param 的 description，否则输出 Summary {{ with .Param \u0026#34;description\u0026#34; }} {{ . }} {{ else }} {{ .Summary }} {{ end }} 函数调用 # 在 hugo 模板中，调用函数格式大致如下：{{ funcName arg1 arg2 \u0026hellip; }}\n模板中函数信息参考： 模板中函数信息 go 复制 1 2 {{ add 1 2 }} // 调用 add 函数，计算 1+2，结果为3 {{ lt 1 2 }} // 调用 lt 函数，计算1\u0026lt;2，结果为true 迭代 # 迭代语句 range 以 {{ end }} 结束\n使用 range 来迭代 map/array/slice 类型变量\n以下是 range 使用的几个示例\ngo 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 这里的上下文 . 是 $array 中的一个元素，要访问全局上下文，需要使用 $. {{ range $array }} {{ . }} {{ end }} // 为数组元素的值声明变量 {{ range $elem_val := $array }} {{ $elem_val }} {{ end }} // 为数组元素的索引和值声明变量 {{ range $elem_index, $elem_val := $array }} {{ $elem_index }} -- {{ $elem_val }} {{ end }} // 为 map 元素的索引和值声明变量 {{ range $elem_key, $elem_val := $map }} {{ $elem_key }} -- {{ $elem_val }} {{ end }} // 传入的 map/array/slice 为空时，执行 else 语句 {{ range $array }} {{ . }} {{else}} // 只有在 $array 为空时才会执行 {{ end }} 遍历其他示例 # go 复制 1 2 3 4 5 6 {{ range .Data.Pages }} // 遍历 Data.Pages {{ range where .Data.Pages \u0026#34;Section\u0026#34; \u0026#34;posts\u0026#34; }} // 遍历 Data.Pages，过滤 Section 为 posts 的数据 {{ range first 10 .Data.Pages }} // 遍历 Data.Pages，取前10条数据 {{ range last 10 .Data.Pages }} // 遍历 Data.Pages，取后10条数据 {{ range after 10 .Data.Pages }} // 遍历 Data.Pages，取第10条数据之后的数据 {{ range until 10 .Data.Pages }} // 遍历 Data.Pages，取第10条数据之前的数据 cond # cond CONTROL VAR1 VAR2\n如果 CONTROL 为真，则返回 VAR1，否则返回 VAR2\n模板 # 模板位置始终从 hugo 目录中的 layouts 目录开始查找，如果没有找到，就会从主题目录中查找\n如果在主题目录中也没有找到，就会使用默认的模板\n部分模板 # 使用 partial 函数引用部分模板，部分模板的位置为 layouts/partials。\n语法如下：{{ partial \u0026quot;\u0026lt;PATH\u0026gt;/\u0026lt;PARTIAL\u0026gt;.\u0026lt;EXTENSION\u0026gt;\u0026quot; . }}\ngo 复制 1 2 {{ partial \u0026#34;header.html\u0026#34; . }} 引用部分模板 layouts/partials/header.html {{ partialCached \u0026#34;header.html\u0026#34; . }} 缓存引用部分模板 layouts/partials/header.html 多变量部分模板示例 # go 复制 1 2 3 4 5 6 7 // 传入多个变量 {{ partial \u0026#34;header.html\u0026#34; (dict \u0026#34;curremtPage\u0026#34; . \u0026#34;param1\u0026#34; \u0026#34;1\u0026#34; \u0026#34;param2\u0026#34; \u0026#34;2\u0026#34; ) }} // 模板中使用变量 {{ .curremtPage }} -\u0026gt; . {{ .param1 }} -\u0026gt; \u0026#34;1\u0026#34; {{ .param2 }} -\u0026gt; \u0026#34;2\u0026#34; 引用模板 # 使用 template 函数引用模板，template 函数用于在更旧的 Hugo 版本中包含部分模板。现在它只对调用内部模板有用。\n内部模板信息参考： 内部模板 查看可用的内部模板： 可用的内部模板 语法如下：{{ template \u0026quot;_internal/\u0026lt;TEMPLATE\u0026gt;.\u0026lt;EXTENSION\u0026gt;\u0026quot; . }}\ngo 复制 1 2 {{ template \u0026#34;_internal/opengraph.html\u0026#34; . }} 引用内部模板 opengraph.html {{ template \u0026#34;_internal/_default/rss.xml\u0026#34; . }} 引用内部模板 _default/rss.xml 空格符 # 模板会处理以下空白符\n空格 tab 回车 新行 go 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;div\u0026gt; {{ .Title }} \u0026lt;/div\u0026gt; // 输出 \u0026lt;div\u0026gt; Hello, World! \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {{- .Title -}} \u0026lt;/div\u0026gt; // 输出 \u0026lt;div\u0026gt;Hello, World!\u0026lt;/div\u0026gt; 杂项 # go 复制 1 2 3 4 5 6 7 8 9 10 11 12 13 // 使用名为\u0026#34;main\u0026#34;的块，如果没有定义该块，就会使用默认的块 {{ block \u0026#34;main\u0026#34; . }}{{ end }} // 定义一个名称为\u0026#34;main\u0026#34;的块 {{ define \u0026#34;main\u0026#34; }} \u0026lt;h1\u0026gt;Posts\u0026lt;/h1\u0026gt; {{ range .Pages }} \u0026lt;article\u0026gt; \u0026lt;h2\u0026gt;{{ .Title }}\u0026lt;/h2\u0026gt; {{ .Content }} \u0026lt;/article\u0026gt; {{ end }} {{ end }} 资源 # resources 是一个 Hugo 内置的模块，用于处理网站资源文件，例如图片、CSS、JavaScript 等。它包含了一系列的方法，可以用来获取、操作、组合和匹配资源文件。\nresources.Get: 获取指定路径的资源文件。 resources.Match: 根据指定的 glob 模式匹配资源文件，返回一个资源列表。 resources.Concat: 将多个资源文件合并为一个。 resources.FromString: 从字符串中创建一个资源文件。 resources.ExecuteAsTemplate: 将资源文件作为模板进行解析。 ","permalink":"https://linlccc.com/posts/hugotemplatebasicsyntax/","summary":"概念 # 每一个模板都有一个名为 Page 数据对象 Page 信息参考： Page 信息参考 基础语法 # 访问变量 # go 复制 1 2 {{ .Titel }} // 访问已存在的变量 {{ $address }} // 访问自定义变量 声明","title":"hugo 模板基本语法"},{"content":" 下载 LibTorch # 这里下载的LibTorch版本需要与你的 CUDA 版本一致\n从 LibTorch 下载对应系统的 C++ 版本 下载完成后解压文件，如解压到C:\\libtorch（以下都将以此为libtorch目录） 配置环境变量 # 确保程序在运行时可以找到LibTorch动态链接库，将lib目录添加到环境变量\n在系统搜索查找“编辑系统环境变量”-\u0026gt;”环境变量“ 在“系统变量”中，找到Path变量，点击“编辑”，添加LibTorch的库目录路径C:\\libtorch\\lib vs2022 中的配置 # 如果在配置环境变量之前启动了需要重启\n创建一个 C++ 控制台项目\n配置项目属性 # 常规 C++语言标准：将“语言标准”设置为ISO C++ 14 标准 (/std:c++14)或更高版本 C/C++ 常规 \u0026gt; 附加包含目录：添加C:\\libtorch\\include和C:\\libtorch\\include\\torch\\csrc\\api\\include 链接器 常规 \u0026gt; 附加库目录：添加C:\\libtorch\\lib\n输入 \u0026gt; 附加依赖项：添加以下库\nplaintext 复制 1 2 3 4 C:\\libtorch\\lib\\c10.lib C:\\libtorch\\lib\\torch.lib C:\\libtorch\\lib\\torch_cpu.lib C:\\libtorch\\lib\\torch_cuda.lib (如果使用CUDA) 测试代码 # cpp 复制 1 2 3 4 5 6 7 8 #include \u0026lt;torch/torch.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { torch::Tensor tensor = torch::rand({2, 3}); std::cout \u0026lt;\u0026lt; tensor \u0026lt;\u0026lt; std::endl; return 0; } 设置CMake（可选） # 如果你希望使用CMake进行构建，可以在项目根目录创建一个CMakeLists.txt文件，内容如下：\ncmake 复制 1 2 3 4 5 6 7 8 9 10 cmake_minimum_required(VERSION 3.0 FATAL_ERROR) project(your_project) set(CMAKE_PREFIX_PATH \u0026#34;C:/libtorch\u0026#34;) find_package(Torch REQUIRED) add_executable(your_project main.cpp) target_link_libraries(your_project \u0026#34;${TORCH_LIBRARIES}\u0026#34;) set_property(TARGET your_project PROPERTY CXX_STANDARD 14) 然后在命令行中运行以下命令生成可执行文件：\nbash 复制 1 2 3 4 mkdir build cd build cmake .. cmake --build . 构建是异常笔记 # 找不到 mkl_avx2.1.dll / mkl_def.1.dll # Intel MKL FATAL ERROR: Cannot load mkl_avx2.1.dll or mkl_def.1.dll\n原因是找不到 mkl 2021.4 版的动态依赖库，就算在 oneApi 下载安装了也不行，因为他只提供最新版本 see ,可以使用以下方式解决\n下载 2021.4 版本的动态mkl动态链接库，打开命令行工具输入以下命令：\nbash 复制 1 pip install mkl==2021.4 在 python 的库中将需要的依赖拷贝到项目中，C:\\Users\\[User]\\AppData\\Local\\Programs\\Python\\Python312\\Library\\bin 是 python 安装在默认路径时的库的位置\n","permalink":"https://linlccc.com/posts/cppconfigurelibtorchenvironment/","summary":"下载 LibTorch # 这里下载的LibTorch版本需要与你的 CUDA 版本一致 从 LibTorch 下载对应系统的 C++ 版本 下载完成后解压文件，如解压到C:\\libtorch（以下都","title":"C++ 配置 libtorch 环境"}]