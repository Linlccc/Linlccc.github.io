[{"content":"概念 每一个模板都有一个名为 Page 数据对象\nPage 信息参考：Page 信息参考\n基础语法 访问变量 {{ .Titel }} // 访问已存在的变量 {{ $address }} // 访问自定义变量 声明变量与赋值 {{ $address := \u0026quot;http://www.baidu.com\u0026quot; }} // 声明自定义变量并赋值 {{ $msg := `Line one. Line two.` }} // 支持多行字符串 {{ $msg = \u0026quot;\u0026quot; }} // 将msg的值修改为空字符串 条件语句 条件语句 if/with 都以 {{ end }} 结束\n在hugo模板中，条件语句的条件可以是任何表达式，而不仅仅是布尔类型的表达式，以下情况会被认为是false：\n空字符串 \u0026quot;\u0026quot; 空数组 [] 空字典 map[] 空指针 nil 数值 0 布尔值 false if 很多情况下建议使用 with 语句，而不是 if 语句，因为 with 语句可以重新绑定上下文，而 if 语句不能\n{{ if .IsHome }} {{ end }} // 判断 IsHome 的值 {{ if eq .Title \u0026quot;Home\u0026quot; }} {{ end }} // 判断变量是否相等 {{ if ne .Title \u0026quot;Home\u0026quot; }} {{ end }} // 判断变量是否不相等 {{ if and .IsHome .Params.show }} {{ end }} // 判断多个条件是否同时满足 {{ if or .IsHome .Params.show }} {{ end }} // 判断多个条件是否有一个满足 {{ if not .IsHome }} {{ end }} // 判断条件是否不满足 {{ if strings.Contains \u0026quot;hugo\u0026quot; \u0026quot;go\u0026quot; }} {{end}} // 判断是否包含指定字符串 // 该示例和 with 的第一个示例做完全相同的事 {{ if isset .Params \u0026quot;title\u0026quot; }} \u0026lt;h4\u0026gt;{{ index .Params \u0026quot;title\u0026quot; }}\u0026lt;/h4\u0026gt; {{ end }} // 但是 if 可是使用 else if 语句 {{ if (isset .Params \u0026quot;description\u0026quot;) }} {{ index .Params \u0026quot;description\u0026quot; }} {{ else if (isset .Params \u0026quot;summary\u0026quot;) }} {{ index .Params \u0026quot;summary\u0026quot; }} {{ else }} {{ .Summary }} {{ end }} // 使用 or/and , 只要 .Params.title 或者 .Params.caption 有一个存在，并且 .Params.attr 存在，就会执行该块 {{ if (and (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)) }} \u0026lt;div class=\u0026quot;caption {{ index .Params \u0026quot;attr\u0026quot; }}\u0026quot;\u0026gt; {{ if (isset .Params \u0026quot;title\u0026quot;) }} \u0026lt;h4\u0026gt;{{ index .Params \u0026quot;title\u0026quot; }}\u0026lt;/h4\u0026gt; {{ end }} {{ if (isset .Params \u0026quot;caption\u0026quot;) }} \u0026lt;p\u0026gt;{{ index .Params \u0026quot;caption\u0026quot; }}\u0026lt;/p\u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} with with在其范围内重新绑定上下文.\n// 如果 .Params.title 为空，将跳过该块 {{ with .Params.title }} \u0026lt;h4\u0026gt;{{ . }}\u0026lt;/h4\u0026gt; {{ end }} // 如果 Param 设置了 description，那么输出 Param 的 description，否则输出 Summary {{ with .Param \u0026quot;description\u0026quot; }} {{ . }} {{ else }} {{ .Summary }} {{ end }} 函数调用 在hugo模板中，调用函数格式大致如下：{{ funcName arg1 arg2 \u0026hellip; }}\n模板中函数信息参考：模板中函数信息\n{{ add 1 2 }} // 调用 add 函数，计算 1+2，结果为3 {{ lt 1 2 }} // 调用 lt 函数，计算1\u0026lt;2，结果为true 迭代 迭代语句 range 以 {{ end }} 结束 使用 range 来迭代 map/array/slice 类型变量\n以下是 range 使用的几个示例\n// 这里的上下文 . 是 $array 中的一个元素，要访问全局上下文，需要使用 $. {{ range $array }} {{ . }} {{ end }} // 为数组元素的值声明变量 {{ range $elem_val := $array }} {{ $elem_val }} {{ end }} // 为数组元素的索引和值声明变量 {{ range $elem_index, $elem_val := $array }} {{ $elem_index }} -- {{ $elem_val }} {{ end }} // 为 map 元素的索引和值声明变量 {{ range $elem_key, $elem_val := $map }} {{ $elem_key }} -- {{ $elem_val }} {{ end }} // 传入的 map/array/slice 为空时，执行 else 语句 {{ range $array }} {{ . }} {{else}} // 只有在 $array 为空时才会执行 {{ end }} 遍历其他示例 {{ range .Data.Pages }} // 遍历 Data.Pages {{ range where .Data.Pages \u0026quot;Section\u0026quot; \u0026quot;posts\u0026quot; }} // 遍历 Data.Pages，过滤 Section 为 posts 的数据 {{ range first 10 .Data.Pages }} // 遍历 Data.Pages，取前10条数据 {{ range last 10 .Data.Pages }} // 遍历 Data.Pages，取后10条数据 {{ range after 10 .Data.Pages }} // 遍历 Data.Pages，取第10条数据之后的数据 {{ range until 10 .Data.Pages }} // 遍历 Data.Pages，取第10条数据之前的数据 cond cond CONTROL VAR1 VAR2 如果 CONTROL 为真，则返回 VAR1，否则返回 VAR2\n模板 模板位置始终从hugo目录中的layouts目录开始查找，如果没有找到，就会从主题目录中查找\n如果在主题目录中也没有找到，就会使用默认的模板\n部分模板 使用 partial 函数引用部分模板，部分模板的位置为 layouts/partials。 语法如下：{{ partial \u0026quot;\u0026lt;PATH\u0026gt;/\u0026lt;PARTIAL\u0026gt;.\u0026lt;EXTENSION\u0026gt;\u0026quot; . }}\n{{ partial \u0026quot;header.html\u0026quot; . }} 引用部分模板 layouts/partials/header.html {{ partialCached \u0026quot;header.html\u0026quot; . }} 缓存引用部分模板 layouts/partials/header.html 多变量部分模板示例 // 传入多个变量 {{ partial \u0026quot;header.html\u0026quot; (dict \u0026quot;curremtPage\u0026quot; . \u0026quot;param1\u0026quot; \u0026quot;1\u0026quot; \u0026quot;param2\u0026quot; \u0026quot;2\u0026quot; ) }} // 模板中使用变量 {{ .curremtPage }} -\u0026gt; . {{ .param1 }} -\u0026gt; \u0026quot;1\u0026quot; {{ .param2 }} -\u0026gt; \u0026quot;2\u0026quot; 引用模板 使用 template 函数引用模板，template 函数用于在更旧的 Hugo 版本中包含部分模板。现在它只对调用内部模板有用。\n内部模板信息参考：内部模板\n查看可用的内部模板：可用的内部模板\n语法如下：{{ template \u0026quot;_internal/\u0026lt;TEMPLATE\u0026gt;.\u0026lt;EXTENSION\u0026gt;\u0026quot; . }}\n{{ template \u0026quot;_internal/opengraph.html\u0026quot; . }} 引用内部模板 opengraph.html {{ template \u0026quot;_internal/_default/rss.xml\u0026quot; . }} 引用内部模板 _default/rss.xml 空格符 模板会处理以下空白符\n空格 tab 回车 新行 \u0026lt;div\u0026gt; {{ .Title }} \u0026lt;/div\u0026gt; // 输出 \u0026lt;div\u0026gt; Hello, World! \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {{- .Title -}} \u0026lt;/div\u0026gt; // 输出 \u0026lt;div\u0026gt;Hello, World!\u0026lt;/div\u0026gt; 杂项 // 使用名为\u0026quot;main\u0026quot;的块，如果没有定义该块，就会使用默认的块 {{ block \u0026quot;main\u0026quot; . }}{{ end }} // 定义一个名称为\u0026quot;main\u0026quot;的块 {{ define \u0026quot;main\u0026quot; }} \u0026lt;h1\u0026gt;Posts\u0026lt;/h1\u0026gt; {{ range .Pages }} \u0026lt;article\u0026gt; \u0026lt;h2\u0026gt;{{ .Title }}\u0026lt;/h2\u0026gt; {{ .Content }} \u0026lt;/article\u0026gt; {{ end }} {{ end }} 资源 resources 是一个 Hugo 内置的模块，用于处理网站资源文件，例如图片、CSS、JavaScript 等。它包含了一系列的方法，可以用来获取、操作、组合和匹配资源文件。\nresources.Get: 获取指定路径的资源文件。 resources.Match: 根据指定的 glob 模式匹配资源文件，返回一个资源列表。 resources.Concat: 将多个资源文件合并为一个。 resources.FromString: 从字符串中创建一个资源文件。 resources.ExecuteAsTemplate: 将资源文件作为模板进行解析。 ","permalink":"https://linlccc.com/posts/hugotemplatebasicsyntax/","summary":"概念 每一个模板都有一个名为 Page 数据对象 Page 信息参考：Page 信息参考 基础语法 访问变量 {{ .Titel }} // 访问已存在的变量 {{ $address }} // 访问自定义变量 声明变量与赋值","title":"hugo 模板基本语法"},{"content":"生成新的 SSH 密钥 在终端中输入以下指令以提供的电子邮件为标签创建SSH密钥 ssh-keygen -t rsa -b 4096 -C \u0026quot;[email@example.com]\u0026quot; 根据提示输入密钥保存文件，可空保存到默认文件C:\\Users\\[User]\\.ssh\\id_rsa 根据提示输入两次密码（建议不设置密码，否者每次push都需要输入密码） 将 SSH 密钥添加到 ssh-agent 以管理员权限打开 PowerShell 启动 ssh agent: Get-Service -Name ssh-agent | Set-Service -StartupType Manual Start-Service ssh-agent 将 SSH 私钥添加到 ssh-agent (无需管理员权限) ssh-add C:\\Users\\[User]\\.ssh\\id_rsa 移除 SSH 密钥 删除C:\\Users\\[User]\\.ssh\\文件夹中的两个密钥文件 从ssh agent中移除ssh密钥 # 查看已加载的密钥列表 ssh-add -l # 移除密钥 ssh-add -d C:\\Users\\[User]\\.ssh\\id_rsa ","permalink":"https://linlccc.com/posts/managessh/","summary":"生成新的 SSH 密钥 在终端中输入以下指令以提供的电子邮件为标签创建SSH密钥 ssh-keygen -t rsa -b 4096 -C \u0026quot;[email@example.com]\u0026quot; 根据提示输入密钥保存文件，可空保存到默认文件C:\\Use","title":"管理 SSH"},{"content":"基础 整数类型 这些类型里面除了只有 signed 和 int 的都可以省略 signed / int 例如 short, short int, signed short, signed short int 表示一个类型\n类型 占用字节数 取值范围 signed char 1 -128 到 127 unsigned char 1 0 到 255 short, short int, signed short, signed short int 2 -32768 到 32767 unsigned short, unsigned short int 2 0 到 65535 int, signed, signed int 4 -2147483648 到 2147483647 unsigned, unsigned int 4 0 到 4294967295 long, long int, signed long, signed long int 4 与 int 或 long long 相同 unsigned long, unsigned long int 4 与 unsigned 或 unsigned long long 相同 long long, long long int, signed long long, signed long long int 8 -9223372036854775808 到 9223372036854775807 unsigned long long, unsigned long long int 8 0 到 18446744073709551615 浮点类型 类型 占用字节数 取值范围 float 4 1.175494351e-38 到 3.402823466e+38 double 8 2.2250738585072014e-308 到 1.7976931348623157e+308 long double 12 3.36210314311209350626267781732175260e-4932 到 1.18973149535723176508575932662800702e+4932 无效浮点数信息 在C++中，浮点数类型的值可以是无效的，具体取决于浮点数类型的规范。以下是一些常见的无效浮点数值：\nNaN (Not a Number): 表示无效的计算结果，例如 0.0 / 0.0、sqrt(-1) 等，它可以用 std::numeric_limits\u0026lt;T\u0026gt;::quiet_NaN() 来表示。 Inf (Infinity): 表示除以 0 或者取 log(0) 等无穷值的结果，它可以用 std::numeric_limits\u0026lt;T\u0026gt;::infinity() 来表示。 -Inf (Negative Infinity): 表示除以 -0 或者取 log(-0) 等负无穷值的结果，它可以用 -std::numeric_limits\u0026lt;T\u0026gt;::infinity() 来表示。 denormalized number: 非规格化数，它是一个非零的非规格化浮点数W，不同于规格化数它的指数部分全是 0。在一些平台上，它可能会被截断成 0。 在 C++ 标准库中，可以使用 std::numeric_limits\u0026lt;T\u0026gt; 类模板来获取特定浮点数类型 T 的限制信息，例如 std::numeric_limits\u0026lt;double\u0026gt;::quiet_NaN() 就可以得到 double 类型的 NaN。\n无效浮点数操作 操作 结果 ±value/0 ±Infinity ±Infinity ± value ±Infinity ±Infinity * value ±Infinity ±Infinity / value ±Infinity 0 / 0 NaN ±Infinity / ±Infinity NaN Infinity - Infinity NaN Infinity * 0 NaN 数字字面量 类型 示例 int 42, -123 unsigned int 42u, 123U long 123456L, -123L unsigned long 123456ul, 123ul long long 123456789LL, -123LL unsigned long long 123456789ull, 123ull float 3.14f, -2.5F double 3.14, -2.5 long double 3.14L, -2.5L 进制表示方式 进制 表示方式 示例 二进制 以 0b 或 0B 开头 0b110 八进制 以 0 开头 017 10进制 直接输入数字 123 16进制 以 0x 或 0X 开头 0x1A sizeof 运算符 sizeof(type)：获取类型 type 的大小，返回 size_t 类型的值。 sizeof expression：获取表达式 expression 的大小，返回 size_t 类型的值。 sizeof...：获取模板参数包中元素的个数，返回 size_t 类型的值。这个用法通常用于可变参数模板。 // 获取类型的大小 std::cout \u0026lt;\u0026lt; \u0026quot;sizeof(int): \u0026quot; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; '\\n'; // 获取表达式的大小 int arr[] = {1, 2, 3}; std::cout \u0026lt;\u0026lt; \u0026quot;sizeof(arr): \u0026quot; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; '\\n'; // 获取模板参数包中元素的个数 template\u0026lt;typename... Ts\u0026gt; void foo(Ts... args) { std::cout \u0026lt;\u0026lt; \u0026quot;sizeof...(args): \u0026quot; \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; '\\n'; } foo(1, 'a', 3.14); // 输出 \u0026quot;sizeof...(args): 3\u0026quot; 数值的上下限 std::numeric_limits\u0026lt;T\u0026gt; 类模板提供了获取数值类型 T 的上下限的方法\n// 在整数类型中 min 和 lowest 都是相同的，都是最小值 // 获取 int 类型的上限 std::numeric_limits\u0026lt;int\u0026gt;::max(); // 获取 int 类型的下限 std::numeric_limits\u0026lt;int\u0026gt;::min(); // 以下方法也可以获取下限 std::numeric_limits\u0026lt;int\u0026gt;::lowest(); // 在浮点数类型中，min 和 lowest 不同，min 得到的是最小的正整数，lowest 得到的才是最小的值 // 获取 float 类型的上限（3.40282e+38） std::numeric_limits\u0026lt;float\u0026gt;::max(); // 获取 float 类型的最小的正整数（1.17549e-38） std::numeric_limits\u0026lt;float\u0026gt;::min(); // 获取 float 类型的下限（-3.40282e+38） std::numeric_limits\u0026lt;float\u0026gt;::lowest(); char 、 wchar_t 、 char8_t 、 char16_t 、 char32_t 以上几种都是原生字符类型，用于表示数字、字母、符号等字符。\nchar:\n占用一个字节（8 位） 用于表示单个 8 位字符，即 ASCII 码表中的字符，范围是 0~127 在 C++ 中使用最为广泛，可以用于表示 ANSI 编码和 UTF-8 编码的字符，建议在表示 ASCII 字符时使用。 wchar_t:\n在不同平台上占用的字节数不同，通常为 2 个字节（16 位）或 4 个字节（32 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 在处理 Unicode 字符或多语言环境下有更好的应用场景，建议在需要处理 Unicode 字符时使用。 在些跨平台代码是不建议使用，因为不同平台上的 wchar_t 占用的字节数不同。 char8_t:\n占用一个字节（8 位） 用于表示单个 8 位字符，范围是所有 Unicode 字符中的 ASCII 码表部分，即 0~127 用于表示 UTF-8 编码的字符，建议在需要处理 UTF-8 编码的字符时使用。 char16_t:\n占用两个字节（16 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 用于表示 UTF-16 编码的字符，建议在需要处理 UTF-16 编码的字符时使用。 char32_t:\n占用四个字节（32 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 用于表示 UTF-32 编码的字符，建议在需要处理 UTF-32 编码的字符时使用。 变量初始化赋值 在C++中初始化赋值有三种方式\n建议平时使用花括号表示法，避免隐式类型转换，如果类型不匹配会报错，以达到更好的代码可读性和可维护性 赋值表示法和函数表示法在初始化时不会进行类型检查，如果类型不匹配会进行隐式类型转换（缩窄转换） 赋值表示法和函数表示法在进行缩窄转换时，大多数编译器会发出数据丢失的警告 int i = 0; // 赋值表示法 int j(0); // 函数表示法 int k{0}; // 花括号表示法 int l{}; // 这里是默认赋值为0 显示类型转换 类型转换方式 示例 建议使用方式 C风格类型转换 (float) x 不建议使用 静态/强制类型转换 static_cast\u0026lt;float\u0026gt;(x) 建议使用 重新解释类型的转换 reinterpret_cast\u0026lt;float\u0026gt;(x) 转换指针类型时建议使用 旧式的类型转换 float(x) 不建议使用 格式化字符串 std::format std::format 是 C++20 中的新特性，它提供了一种新的字符串格式化方式。该特性可以用来将多种类型的值格式化为字符串，并且支持多种格式控制符，可以更加灵活地控制输出格式。 这里列出格式说明符的一般形式：{[arg_id][:[[fill]align][sign][\u0026quot;#\u0026quot;][\u0026quot;0\u0026quot;][width][\u0026quot;.\u0026quot; precision][\u0026quot;L\u0026quot;][type]]}\narg_id：表示参数的索引, 从 0 开始\nfill：指定填充字符，可以是任意字符。如果省略，则默认为空格。\nstd::format(\u0026quot;|{:\u0026lt;10}|\u0026quot;, \u0026quot;hello\u0026quot;); // |hello | std::format(\u0026quot;|{:*\u0026lt;10}|\u0026quot;, \u0026quot;hello\u0026quot;); // |hello*****| align：指定对齐方式，可以是以下几种：\n\u0026lt;：左对齐。 \u0026gt;: 右对齐。 ^: 居中对齐。 std::format(\u0026quot;|{:\u0026lt;10}|\u0026quot;, \u0026quot;hello\u0026quot;); // |hello | std::format(\u0026quot;|{:\u0026gt;10}|\u0026quot;, \u0026quot;hello\u0026quot;); // | hello| std::format(\u0026quot;|{:^10}|\u0026quot;, \u0026quot;hello\u0026quot;); // | hello | sign：指定符号显示方式，可以是以下几种：\n+：显示正号和负号。 -：只显示负号。 ``（空格）：在正数前面加空格，负数前面加负号（默认）。 std::format(\u0026quot;|{:+}|\u0026quot;, 10); // |+10| std::format(\u0026quot;|{:+}|\u0026quot;, -10); // |-10| std::format(\u0026quot;|{:-}|\u0026quot;, -10); // |-10| std::format(\u0026quot;|{: }|\u0026quot;, 10); // | 10| std::format(\u0026quot;|{: }|\u0026quot;, -10); // |-10| #：指定转换类型，可以是以下几种：\nb 或 B：二进制。 o 或 O：八进制。 x 或 X：十六进制。 e 或 E：科学计数法。 f 或 F：浮点数（默认）。 g 或 G：自动选择 f 或 e。 a 或 A：十六进制浮点数。 std::format(\u0026quot;|{:#x}|\u0026quot;, 255); // |0xff| std::format(\u0026quot;|{:#X}|\u0026quot;, 255); // |0xFF| std::format(\u0026quot;|{:#b}|\u0026quot;, 255); // |0b11111111| std::format(\u0026quot;|{:#o}|\u0026quot;, 255); // |0377| std::format(\u0026quot;|{:.2e}|\u0026quot;, 123.456); // |1.23e+02| std::format(\u0026quot;|{:.2f}|\u0026quot;, 123.456); // |123.46| std::format(\u0026quot;|{:.2g}|\u0026quot;, 123.456); // |1.2e+02| width：指定输出宽度，如果输出的字符串宽度小于指定的宽度，则会在左侧或右侧填充指定字符。\n.precision：指定浮点数输出的精度，即小数点后保留的位数\n常用转义字符 转义字符 含义 \\n 换行符（windows中是\\r\\n） \\r 回车符 \\t 垂直制表符 \\v 水平制表符 \\ 反斜杠 ' 单引号 \u0026quot; 双引号 常用预处理指令 预处理指令 含义 #if 用于条件编译，如果条件为真，则编译后面的代码，否则跳过后面的代码 #ifdef 用于条件编译，如果宏定义了，则编译后面的代码，否则跳过后面的代码 #ifndef 用于条件编译，如果宏没有定义，则编译后面的代码，否则跳过后面的代码 #else 用于条件编译，如果条件为假，则编译后面的代码，否则跳过后面的代码 #endif 用于条件编译，结束条件编译，与 #if 配对使用 #define 用于定义宏，可以用于条件编译，也可以用于替换代码中的字符串 #undef 用于取消宏定义，与 #define 配对使用 #error 用于输出错误信息，编译时会报错 #line 用于指定行号，与 #file 配对使用 #file 用于指定文件名，与 #line 配对使用 #pragma 用于指定编译器的行为，如指定编译器忽略警告 ","permalink":"https://linlccc.com/posts/cppstudynotes/","summary":"基础 整数类型 这些类型里面除了只有 signed 和 int 的都可以省略 signed / int 例如 short, short int, signed short, signed short int 表示一个类型 类型 占用字节数 取值范围 signed char 1 -128 到 127 unsigned char 1 0 到 255 short, short int,","title":"C++ 学习笔记"},{"content":"正则表达式 1. Safari 处理正则表达式中的正向后行断言时(?\u0026lt;=\u0026hellip;)，异常 // 以下代码在 Chrome 中正常，但在 Safari 中会报错 \u0026quot;https://linlccc.com?theme=light\u0026quot;.replace(/(?\u0026lt;=[?|\u0026amp;]theme=)\\w+/, \u0026quot;dark\u0026quot;); // 解决方案，使用捕捉组+替换字符串的方式 \u0026quot;https://linlccc.com?theme=light\u0026quot;.replace(/([?|\u0026amp;]theme=)\\w+/, \u0026quot;$1dark\u0026quot;); // 以上两个执行结果都是 \u0026quot;https://linlccc.com?theme=dark\u0026quot; ","permalink":"https://linlccc.com/posts/saferisteppingonthepit/","summary":"正则表达式 1. Safari 处理正则表达式中的正向后行断言时(?\u0026lt;=\u0026hellip;)，异常 // 以下代码在 Chrome 中正常，但在 Safari 中会报错 \u0026quot;https://linlccc.com?theme=light\u0026quot;.replace(/(?\u0026lt;=[?|\u0026amp;]theme=)\\w+/, \u0026quot;dark\u0026quot;); // 解决方案，使用","title":"踩坑记--Safari之正向后行断言"},{"content":"游戏\n","permalink":"https://linlccc.com/games/g1/","summary":"游戏","title":"G1"}]