[{"content":"基础扩展 Chinese (Simplified) see 1 VS Code 的中文（简体）语言包 vscode-icons see 1 图标 XML，Json，TOML 扩展 XML see 1 XML 支持 JSON Crack see 1 Json 数据可视化 Even Better TOML see 1 TOML 语言支持 Markdown All in One see 1 Markdown 快捷键等支持 Markdown Preview Enhanced see 1 Markdown 预览 markdownlint see 1 Markdown 语法检查 C# 扩展 .NET Install Tool see 1 此扩展安装和管理不同版本的 .NET SDK 和运行时 C# see 依赖 .NET Install Tool 1 C# 的基本语言支持 C# Dev Kit see 依赖 .NET Install Tool C# 1 2 3 帮助 C# 开发人员更快、更快速地编写、调试和维护其代码 ps: 此扩展依赖以上两个扩展，直接安装该扩展即可 Js 扩展 Regex Previewer see 1 2 正则表达式测试 在js文件中输入正则表达式按下 Ctrl+Alt+M` 即可快速测试 Turbo Console Log see 1 在变量上按下 Ctrl+Alt+L` 快速添加 console.log 代码 Path Intellisense see 1 自动完成路径文件名 Vetur see 1 Vue 开发工具 Vue - Official see 1 Vue 支持 Web Live Server see 1 启动具有静态和动态页面实时重新加载功能的开发本地服务器 Thunder Client see 1 API 客户端 格式化扩展 Prettier see 1 支持 JavaScript · TypeScript · Flow · JSX · JSON · CSS · SCSS · Less · HTML · Vue · Angular HANDLEBARS · Ember · Glimmer · GraphQL · Markdown · YAML 代码格式化 Ai 扩展 Fitten Code see 1 AI 代码助手 ","permalink":"https://linlccc.com/posts/vscodeextensions/","summary":"基础扩展 Chinese (Simplified) see 1 VS Code 的中文（简体）语言包 vscode-icons see 1 图标 XML，Json，TOML 扩展 XML see 1 XML 支持 JSON Crack see 1 Json 数据可视化 Even Better TOML see 1 TOML 语言支持 Markdown All in One see 1 Markdown 快捷键等支持 Markdown Preview Enhanced see 1 Markdown 预览 markdownlint see 1 Markdown 语法检查 C# 扩展 .NET Install","title":"VsCode 常用扩展推荐"},{"content":"axios.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import axios from \u0026#39;axios\u0026#39; // 文档：https://github.com/axios/axios#request-config // axios 全局默认配置 // axios.defaults.baseURL = process.env.baseURL || process.env.apiUrl || \u0026#39;https://api.apiopen.top/\u0026#39;;//设置默认请求路径 // axios.defaults.headers.common[\u0026#39;Authorization\u0026#39;] = AUTH_TOKEN; // axios.defaults.headers.post[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/x-www-form-urlencoded\u0026#39;; // 自定义实例配置 const config = { // baseURL: process.env.baseURL || process.env.apiUrl || \u0026#39;https://api.apiopen.top/\u0026#39; // timeout: 60 * 1000, // 超时 // withCredentials: true, // 检查跨域访问控制 } axios.create(config) // 添加请求拦截器 axios.interceptors.request.use( config =\u0026gt; { console.log(\u0026#39;请求全局拦截\u0026#39;) // 请求之前处理 return config }, error =\u0026gt; { // 处理请求错误 return Promise.reject(error) } ) // 添加响应拦截器 axios.interceptors.response.use( response =\u0026gt; { // 处理响应数据 return response }, error =\u0026gt; { // 处理响应错误 return Promise.reject(error) } ) export { axios } export default (app: any) =\u0026gt; { app.config.globalProperties.$axios = axios } main.ts 1 2 3 4 5 // 导入封装的axios import installAxios from \u0026#39;./axios\u0026#39; const app = createApp(App) installAxios(app)// 使用axios api.ts 使用 axios 制定接口函数 1 2 3 4 5 6 7 8 9 10 11 // 导入封装的axios import { axios } from \u0026#39;./axios\u0026#39; // 调用接口1 export const api1 = async (params: any) =\u0026gt; { return axios.get(\u0026#39;/api/api1\u0026#39;, { params: params }) } export const api2 = async (params: any) =\u0026gt; { return axios.post(\u0026#39;/api/api2\u0026#39;, { params: params }) } test.vue 调用接口 1 2 3 4 // 导入api import { api1 } from \u0026#39;./api\u0026#39; api1(params).then(res=\u0026gt;console.log(res)); ","permalink":"https://linlccc.com/posts/axiosinvue/","summary":"axios.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import axios from \u0026#39;axios\u0026#39; // 文档：https://github.com/axios/axios#request-conf","title":"在 Vue 中使用 Axios"},{"content":"1、实现原生的AJAX请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const ajax = { get(url, fn) { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;GET\u0026#39;, url, true)// 第三个参数异步与否 xhr.onreadystatechange = function() { if (xhr.readyState === 4) { fn(xhr.responeText) } } xhr.send() }, post(url, data, fn) { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;POST\u0026#39;, url, true) xhr.setRequestHeader(\u0026#39;Content-type\u0026#39;,\u0026#39;application/x-www-form-urlencoded\u0026#39;) xhr.onreadystatechange = function () { if (xhr.readyState === 4) { fn(xhr.responeText) } } xhr.send(data) } } 2、手写 new 的过程 1 2 3 4 5 6 7 8 9 10 function myNew(fn, ...args) { const obj = {} obj.__proto__ = fn.prototype fn.apply(obj, args) return obj } 3、instanceof关键字 1 2 3 4 5 6 7 8 9 10 11 12 13 function instanceOf(father, child) { const fp = father.prototype var cp = child.__proto__ while (cp) { if (cp === fp) { return true } cp = cp.__proto__ } return false } 4、实现防抖函数 1 2 3 4 5 6 7 8 9 10 11 12 function debounce(fn, delay = 500) { let timer; return function () { if (timer) { clearTimeout(timer) } const args = arguments timer = setTimeout(() =\u0026gt; { fn.apply(this, args) // 改变this指向为调用debounce所指的对象 }, delay) } } 5、实现节流函数 1 2 3 4 5 6 7 8 9 10 11 12 function throttle(fn, delay = 200) { let flag = true return function () { if (!flag) return flag = false const args = arguments setTimeout(() =\u0026gt; { fn.apply(this, args) flag = true }, delay) } } 6、实现数组去重 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 第一种：Map记录 function quchong1(arr) { const newArr = [] arr.reduce((pre, next) =\u0026gt; { if (!pre.has(next)) { pre.set(next, 1) newArr.push(next) } return pre }, new Map()) return newArr } // 第二种：Set去重 function quchong2(arr) { return [...new Set(arr)] } 7、用setTimeout实现setInterval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function mySetTimout(fn, delay) { let timer = null const interval = () =\u0026gt; { fn() timer = setTimeout(interval, delay) } setTimeout(interval, delay) return { cancel: () =\u0026gt; { clearTimeout(timer) } } } // 测试 const { cancel } = mySetTimout(() =\u0026gt; console.log(888), 1000) setTimeout(() =\u0026gt; { cancel() }, 4000) 8、用setInterval实现setTimeout 1 2 3 4 5 6 7 8 9 function mySetInterval(fn, delay) { const timer = setInterval(() =\u0026gt; { fn() clearInterval(timer) }, delay) } // 测试 mySetInterval(() =\u0026gt; console.log(888), 1000) 9、实现一个compose函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function fn1(x) { return x + 1; } function fn2(x) { return x + 2; } function fn3(x) { return x + 3; } function fn4(x) { return x + 4; } const a = compose(fn1, fn2, fn3, fn4); console.log(a) console.log(a(1)); // 1+2+3+4=11 // 实现如下： function compose(...fn) { if (fn.length === 0) return (num) =\u0026gt; num if (fn.length === 1) return fn[0] return fn.reduce((pre, next) =\u0026gt; { return (num) =\u0026gt; { return next(pre(num)) } }) } 10、实现一个科里化函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const add = (a, b, c) =\u0026gt; a + b + c; const a = currying(add, 1); console.log(a(2,3)) // 1 + 2 + 3=6 // 实现如下： function currying(fn, ...args1) { // 获取fn参数有几个 const length = fn.length let allArgs = [...args1] const res = (...arg2) =\u0026gt; { allArgs = [...allArgs, ...arg2] // 长度相等就返回执行结果 if (allArgs.length === length) { return fn(...allArgs) } else { // 不相等继续返回函数 return res } } return res } // 测试： const add = (a, b, c) =\u0026gt; a + b + c; const a = currying(add, 1); console.log(a(2,3)) 11、实现一个LRU缓存函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 实现如下： class LRUCache { constructor(size) { this.size = size this.cache = new Map() } get(key) { const hasKey = this.cache.has(key) if (hasKey) { const val = this.cache.get(key) this.cache.delete(key) this.cache.set(key, val) return val } else { return -1 } } put(key, val) { const hasKey = this.cache.has(key) if (hasKey) { this.cache.delete(key) } this.cache.set(key, val) if (this.cache.size \u0026gt; this.size) { this.cache.delete(this.cache.keys().next().value) } } } 12、简单实现 发布订阅模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class EventEmitter { constructor() { this.cache = {} } on(name, fn) { const tasks = this.cache[name] if (tasks) { this.cache[name].push(fn) } else { this.cache[name] = [fn] } } off(name, fn) { const tasks = this.cache[name] if (task) { const index = tasks.findIndex(item =\u0026gt; item === fn) if (index \u0026gt;= 0) { this.cache[name].splice(index, 1) } } } emit(name, ...args) { // 复制一份。防止回调里继续on，导致死循环 const tasks = this.cache[name].slice() if (tasks) { for (let fn of tasks) { fn(...args) } } } once(name, cb) { function fn(...args) { cb(args) this.off(name, fn) } this.on(name, fn) } } 13、实现JSON.parse 1 2 3 function parse (json) { return eval(\u0026#34;(\u0026#34; + json + \u0026#34;)\u0026#34;); } 14、将DOM转化成树结构对象 1 2 3 4 5 6 7 \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 将上方的DOM转化为下面的树结构对象 { tag: \u0026#39;DIV\u0026#39;, children: [ { tag: \u0026#39;SPAN\u0026#39;, children: [] }, { tag: \u0026#39;UL\u0026#39;, children: [ { tag: \u0026#39;LI\u0026#39;, children: [] }, { tag: \u0026#39;LI\u0026#39;, children: [] } ] } ] } // 实现如下： function dom2tree(dom) { const obj = {} obj.tag = dom.tagName obj.children = [] dom.childNodes.forEach(child =\u0026gt; obj.children.push(dom2tree(child))) return obj } 15、将树结构转换为DOM 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 树结构 {tag: \u0026#39;DIV\u0026#39;, children: [ { tag: \u0026#39;SPAN\u0026#39;, children: [] }, { tag: \u0026#39;UL\u0026#39;, children: [ { tag: \u0026#39;LI\u0026#39;, children: [] }, { tag: \u0026#39;LI\u0026#39;, children: [] } ] } ] } // 实现如下： // 真正的渲染函数 function _render(vnode) { // 如果是数字类型转化为字符串 if (typeof vnode === \u0026#34;number\u0026#34;) { vnode = String(vnode); } // 字符串类型直接就是文本节点 if (typeof vnode === \u0026#34;string\u0026#34;) { return document.createTextNode(vnode); } // 普通DOM const dom = document.createElement(vnode.tag); if (vnode.attrs) { // 遍历属性 Object.keys(vnode.attrs).forEach((key) =\u0026gt; { const value = vnode.attrs[key]; dom.setAttribute(key, value); }); } // 子数组进行递归操作 vnode.children.forEach((child) =\u0026gt; dom.appendChild(_render(child))); return dom; } 1 2 3 4 5 6 7 8 \u0026lt;!-- 转换后的dom --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 16、判断一个对象有环引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var obj = { a: { c: [ 1, 2 ] }, b: 1 } obj.a.c.d = obj console.log(cycleDetector(obj)) // true // 实现思路：用一个数组存储每一个遍历过的对象，下次找到数组中存在，则说明环引用 function cycleDetector(obj) { const arr = [obj] let flag = false function cycle(o) { const keys = Object.keys(o) for (const key of keys) { const temp = o[key] if (typeof temp === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; temp !== null) { if (arr.indexOf(temp) \u0026gt;= 0) { flag = true return } arr.push(temp) cycle(temp) } } } cycle(obj) return flag } 17、计算一个对象的层数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const obj = { a: { b: [1] }, c: { d: { e: { f: 1 } } } } console.log(loopGetLevel(obj)) // 4 // 实现如下: function loopGetLevel(obj) { var res = 1; function computedLevel(obj, level) { var level = level ? level : 0; if (typeof obj === \u0026#39;object\u0026#39;) { for (var key in obj) { if (typeof obj[key] === \u0026#39;object\u0026#39;) { computedLevel(obj[key], level + 1); } else { res = level + 1 \u0026gt; res ? level + 1 : res; } } } else { res = level \u0026gt; res ? level : res; } } computedLevel(obj) return res } 18、对象的扁平化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 const obj = { a: { b: 1, c: 2, d: {e: 5} }, b: [1, 3, {a: 2, b: 3}], c: 3 } flatten(obj) // 结果返回如下 // { // \u0026#39;a.b\u0026#39;: 1, // \u0026#39;a.c\u0026#39;: 2, // \u0026#39;a.d.e\u0026#39;: 5, // \u0026#39;b[0]\u0026#39;: 1, // \u0026#39;b[1]\u0026#39;: 3, // \u0026#39;b[2].a\u0026#39;: 2, // \u0026#39;b[2].b\u0026#39;: 3 // c: 3 // } // 实现如下： const isObject = (val) =\u0026gt; typeof val === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; val !== null function flatten(obj) { if (!isObject(obj)) return const res = {} const dfs = (cur, prefix) =\u0026gt; { if (isObject(cur)) { if (Array.isArray(cur)) { cur.forEach((item, index) =\u0026gt; { dfs(item, `${prefix}[${index}]`) }) } else { for(let key in cur) { dfs(cur[key], `${prefix}${prefix ? \u0026#39;.\u0026#39; : \u0026#39;\u0026#39;}${key}`) } } } else { res[prefix] = cur } } dfs(obj, \u0026#39;\u0026#39;) return res } // 测试 console.log(flatten(obj)) 19、实现(a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3)为true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 第一种方法 var a = { i: 1, toString: function () { return a.i++; } } console.log(a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3) // true // 第二种方法 var a = [1, 2, 3]; a.join = a.shift; console.log(a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3); // true // 第三种方法 var val = 0; Object.defineProperty(window, \u0026#39;a\u0026#39;, { get: function () { return ++val; } }); console.log(a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3) // true 20、实现限制并发的Promise调度器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 addTask(1000,\u0026#34;1\u0026#34;); addTask(500,\u0026#34;2\u0026#34;); addTask(300,\u0026#34;3\u0026#34;); addTask(400,\u0026#34;4\u0026#34;); // 的输出顺序是：2 3 1 4 // 整个的完整执行流程： // 一开始1,2两个任务开始执行 // 500ms时，2任务执行完毕，输出2，任务3开始执行 // 800ms时，3任务执行完毕，输出3，任务4开始执行 // 1000ms时，1任务执行完毕，输出1，此时只剩下4任务在执行 // 1200ms时，4任务执行完毕，输出4 // 实现如下： class Scheduler { constructor(limit) { this.queue = [] this.limit = limit this.count = 0 } add(time, order) { const promiseCreator = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(order) resolve() }, time) }) } this.queue.push(promiseCreator) } taskStart() { for(let i = 0; i \u0026lt; this.limit; i++) { this.request() } } request() { if (!this.queue.length || this.count \u0026gt;= this.limit) return this.count++ this.queue.shift()().then(() =\u0026gt; { this.count-- this.request() }) } } // 测试 const scheduler = new Scheduler(2); const addTask = (time, order) =\u0026gt; { scheduler.add(time, order); }; addTask(1000, \u0026#34;1\u0026#34;); addTask(500, \u0026#34;2\u0026#34;); addTask(300, \u0026#34;3\u0026#34;); addTask(400, \u0026#34;4\u0026#34;); scheduler.taskStart(); 21、实现lazyMan函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // 实现一个LazyMan，可以按照以下方式调用: LazyMan(“Hank”) /** 输出: * Hi! This is Hank! */ LazyMan(“Hank”).sleep(10).eat(“dinner”) /** 输出: * Hi! This is Hank! * //等待10秒.. * Wake up after 10 * Eat dinner~ */ LazyMan(“Hank”).eat(“dinner”).eat(“supper”) /** 输出: * Hi This is Hank! * Eat dinner~ * Eat supper~ */ LazyMan(“Hank”).eat(“supper”).sleepFirst(5) /** 输出: * //等待5秒 * Wake up after 5 * Hi This is Hank! * Eat supper */ // 实现如下： class _LazyMan { constructor(name) { this.tasks = [] const task = () =\u0026gt; { console.log(`Hi! This is ${name}`) this.next() } this.tasks.push(task) setTimeout(() =\u0026gt; { this.next() }, 0) } next() { const task = this.tasks.shift() task \u0026amp;\u0026amp; task() } sleep(time) { this.sleepWrapper(time, false) return this } sleepFirst(time) { this.sleepWrapper(time, true) return this } sleepWrapper(time, first) { const task = () =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`Wake up after ${time}`) this.next() }, time * 1000) } if (first) { this.tasks.unshift(task) } else { this.tasks.push(task) } } eat(food) { const task = () =\u0026gt; { console.log(`Eat ${food}`); this.next(); }; this.tasks.push(task); return this; } } // 测试 const lazyMan = (name) =\u0026gt; new _LazyMan(name) lazyMan(\u0026#39;Hank\u0026#39;).sleep(1).eat(\u0026#39;dinner\u0026#39;) lazyMan(\u0026#39;Hank\u0026#39;).eat(\u0026#39;dinner\u0026#39;).eat(\u0026#39;supper\u0026#39;) lazyMan(\u0026#39;Hank\u0026#39;).eat(\u0026#39;supper\u0026#39;).sleepFirst(5) 22、实现add函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 add(1)(2)(3)()=6 add(1,2,3)(4)()=10 function add(...args1) { let allArgs = [...args1] function fn(...args2) { if (!args2.length) return fn.toString() allArgs = [...allArgs, ...args2] return fn } fn.toString = function () { return allArgs.reduce((pre, next) =\u0026gt; pre + next) } return fn } // 测试 console.log(add(1)(2)(3)()) console.log(add(1, 2)(3)()) 23、实现一个合格的深拷贝 深拷贝有这5个段位？\n24、实现 Promise 手写Promise\n25、实现 async/await 7张图，20分钟就能搞定的async/await原理\n26、forEach 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 参数代表含义 item：遍历项 index：遍历项的索引 arr：数组本身 Array.prototype.sx_forEach = function (callback) { for (let i = 0; i \u0026lt; this.length; i++) { callback(this[i], i, this) } } players.sx_forEach((item, index, arr) =\u0026gt; { console.log(item, index) }) // { name: \u0026#39;科比\u0026#39;, num: 24 } 0 // { name: \u0026#39;詹姆斯\u0026#39;, num: 23 } 1 // { name: \u0026#39;保罗\u0026#39;, num: 3 } 2 // { name: \u0026#39;威少\u0026#39;, num: 0 } 3 // { name: \u0026#39;杜兰特\u0026#39;, num: 35 } 4 27、map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /**参数代表含义 * * item：遍历项 * index：遍历项的索引 * arr：数组本身 */ Array.prototype.sx_map = function (callback) { const res = [] for (let i = 0; i \u0026lt; this.length; i++) { res.push(callback(this[i], i, this)) } return res } console.log(players.sx_map((item, index) =\u0026gt; `${item.name}--${item.num}--${index}`)) // [ \u0026#39;科比--24--0\u0026#39;, \u0026#39;詹姆斯--23--1\u0026#39;, \u0026#39;保罗--3--2\u0026#39;, \u0026#39;威少--0--3\u0026#39;, \u0026#39;杜兰特--35--4\u0026#39; ] 28、filter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Array.prototype.sx_filter = function (callback) { const res = [] for (let i = 0; i \u0026lt; this.length; i++) { callback(this[i], i, this) \u0026amp;\u0026amp; res.push(this[i]) } return res } console.log(players.sx_filter(item =\u0026gt; item.num \u0026gt;= 23)) // [ // { name: \u0026#39;科比\u0026#39;, num: 24 }, // { name: \u0026#39;詹姆斯\u0026#39;, num: 23 }, // { name: \u0026#39;杜兰特\u0026#39;, num: 35 } // ] 29、every 1 2 3 4 5 6 7 8 9 10 11 12 Array.prototype.sx_every = function (callback) { let flag = true for (let i = 0; i \u0026lt; this.length; i++) { flag = callback(this[i], i, this) if (!flag) break } return flag } console.log(players.sx_every(item =\u0026gt; item.num \u0026gt;= 23)) // false console.log(players.sx_every(item =\u0026gt; item.num \u0026gt;= 0)) // true 30、some 1 2 3 4 5 6 7 8 9 10 11 12 Array.prototype.sx_some = function (callback) { let flag = false for (let i = 0; i \u0026lt; this.length; i++) { flag = callback(this[i], i, this) if (flag) break } return flag } console.log(players.sx_some(item =\u0026gt; item.num \u0026gt;= 23)) // true console.log(players.sx_some(item =\u0026gt; item.num \u0026gt;= 50)) // false 31、reduce 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /**参数代表含义 * * pre：前一项 * next：下一项 * index：当前索引 * arr：数组本身 */ Array.prototype.sx_reduce = function (callback, ...args) { let start = 0, pre if (args.length) { pre = args[0] } else { pre = this[0] start = 1 } for (let i = start; i \u0026lt; this.length; i++) { pre = callback(pre, this[i], i, this) } return pre } // 计算所有num相加 const sum = players.sx_reduce((pre, next) =\u0026gt; { return pre + next.num }, 0) console.log(sum) // 85 32、findIndex 1 2 3 4 5 6 7 8 9 10 11 Array.prototype.sx_findIndex = function (callback) { for (let i = 0; i \u0026lt; this.length; i++) { if (callback(this[i], i, this)) { return i } } return -1 } console.log(players.sx_findIndex(item =\u0026gt; item.name === \u0026#39;科比\u0026#39;)) // 0 console.log(players.sx_findIndex(item =\u0026gt; item.name === \u0026#39;安东尼\u0026#39;)) // -1 33、find 1 2 3 4 5 6 7 8 9 10 11 Array.prototype.sx_find = function (callback) { for (let i = 0; i \u0026lt; this.length; i++) { if (callback(this[i], i, this)) { return this[i] } } return undefined } console.log(players.sx_find(item =\u0026gt; item.name === \u0026#39;科比\u0026#39;)) // { name: \u0026#39;科比\u0026#39;, num: 24 } console.log(players.sx_find(item =\u0026gt; item.name === \u0026#39;安东尼\u0026#39;)) // undefined 34、fill 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /**参数代表含义 * * initValue：填充的值 * start：开始填充索引，默认0 * end：结束填充索引，默认length */ // 用处：填充数组 Array.prototype.sx_fill = function (value, start = 0, end) { end = end || this.length for (let i = start; i \u0026lt; end; i++) { this[i] = value } return this } console.log(players.sx_fill(\u0026#39;林三心\u0026#39;, 1, 3)) // [ // { name: \u0026#39;科比\u0026#39;, num: 24 }, // \u0026#39;林三心\u0026#39;, // \u0026#39;林三心\u0026#39;, // \u0026#39;林三心\u0026#39;, // { name: \u0026#39;杜兰特\u0026#39;, num: 35 } // ] 35、includes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 用处：查找元素，查到返回true，反之返回false，可查找NaN Array.prototype.sx_includes = function (value, start = 0) { if (start \u0026lt; 0) start = this.length + start const isNaN = Number.isNaN(value) for (let i = start; i \u0026lt; this.length; i++) { if (this[i] === value || (isNaN \u0026amp;\u0026amp; Number.isNaN(this[i])) { return true } } return false } console.log([1, 2, 3].sx_includes(2)) // true console.log([1, 2, 3, NaN].sx_includes(NaN)) // true console.log([1, 2, 3].sx_includes(1, 1)) // false 36、join 1 2 3 4 5 6 7 8 9 10 11 12 // 用处：将数组用分隔符拼成字符串，分隔符默认为, Array.prototype.sx_join = function (s = \u0026#39;,\u0026#39;) { let str = \u0026#39;\u0026#39; for(let i = 0; i \u0026lt; this.length; i++) { str = i === 0 ? `${str}${this[i]}` : `${str}${s}${this[i]}` } return str } console.log([1, 2, 3].sx_join()) // 1,2,3 console.log([1, 2, 3].sx_join(\u0026#39;*\u0026#39;)) // 1*2*3 37、flat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Array.prototype.sx_flat = function (num = Infinity) { let arr = this let i = 0 while (arr.some(item =\u0026gt; Array.isArray(item))) { arr = [].concat(...arr) i++ if (i \u0026gt;= num) break } return arr } const testArr = [1, [2, 3, [4, 5]], [8, 9]] console.log(testArr.sx_flat(1)) // [1, 2, 3, 4, 5, 8, 9] 38、splice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Array.prototype.sx_splice = function (start, length, ...values) { if (length === 0) return [] length = start + length \u0026gt; this.length - 1 ? this.length - start : length console.log(length) const res = [], tempArr = [...this] for (let i = start; i \u0026lt; start + values.length; i++) { this[i] = values[i - start] } this.length = start + values.length if (values.length \u0026lt; length) { const cha = length - values.length console.log(cha) for (let i = start + values.length; i \u0026lt; tempArr.length; i++) { this[i] = tempArr[i + cha] } this.length = this.length - cha } if (values.length \u0026gt; length) { for (let i = start + length; i \u0026lt; tempArr.length; i++) { this.push(tempArr[i]) } } for (let i = start; i \u0026lt; start + length; i++) { res.push(tempArr[i]) } return res } 39、entries 1 2 3 4 5 6 7 8 9 10 11 12 用处：将对象转成键值对数组 Object.prototype.sx_entries = function (obj) { const res = [] for (let key in obj) { obj.hasOwnProperty(key) \u0026amp;\u0026amp; res.push([key, obj[key]]) } return res } console.log(Object.sx_entries(obj)) // [ [ \u0026#39;name\u0026#39;, \u0026#39;林三心\u0026#39; ], [ \u0026#39;age\u0026#39;, 22 ], [ \u0026#39;gender\u0026#39;, \u0026#39;男\u0026#39; ] ] 40、fromEntries 1 2 3 4 5 6 7 8 9 10 11 12 13 // 用处：跟entries相反，将键值对数组转成对象 Object.prototype.sx_fromEntries = function (arr) { const obj = {} for (let i = 0; i \u0026lt; arr.length; i++) { const [key, value] = arr[i] obj[key] = value } return obj } console.log(Object.sx_fromEntries([[\u0026#39;name\u0026#39;, \u0026#39;林三心\u0026#39;], [\u0026#39;age\u0026#39;, 22], [\u0026#39;gender\u0026#39;, \u0026#39;男\u0026#39;]])) // { name: \u0026#39;林三心\u0026#39;, age: 22, gender: \u0026#39;男\u0026#39; } 41、keys 1 2 3 4 5 6 7 8 9 10 11 12 // 用处：将对象的key转成一个数组合集 Object.prototype.sx_keys = function (obj) { const keys = [] for (let key in obj) { obj.hasOwnProperty(key) \u0026amp;\u0026amp; res.push(key) } return keys } console.log(Object.keys(obj)) // [ \u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39; ] 42、values 1 2 3 4 5 6 7 8 9 10 11 12 // 用处：将对象的所有值转成数组合集 Object.prototype.sx_values = function (obj) { const values = [] for (let key in obj) { obj.hasOwnProperty(key) \u0026amp;\u0026amp; values.push(obj[key]) } return values } console.log(Object.sx_values(obj)) // [ \u0026#39;林三心\u0026#39;, 22, \u0026#39;男\u0026#39; ] 43、instanceOf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 用处：A instanceOf B，判断A是否经过B的原型链 function instanceOf(father, child) { const fp = father.prototype var cp = child.__proto__ while (cp) { if (cp === fp) { return true } cp = cp.__proto__ } return false } function Person(name) { this.name = name } const sx = new Person(\u0026#39;林三心\u0026#39;) console.log(instanceOf(Person, sx)) // true console.log(instanceOf(Person, sx2)) // false 44、is 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 用处：Object.is(a, b)，判断a是否等于b Object.prototype.sx_is = function (x, y) { if (x === y) { // 防止 -0 和 +0 return x !== 0 || 1 / x === 1 / y } // 防止NaN return x !== x \u0026amp;\u0026amp; y !== y } const a = { name: \u0026#39;林三心\u0026#39; } const b = a const c = { name: \u0026#39;林三心\u0026#39; } console.log(Object.sx_is(a, b)) // true console.log(Object.sx_is(a, c)) // false 45、Object.assign 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /**难点 * * assign接收多个对象，并将多个对象合成一个对象 * 这些对象如果有重名属性，以后来的对象属性值为准 * assign返回一个对象，这个对象 === 第一个对象 */ Object.prototype.sx_assign = function (target, ...args) { if (target === null || target === undefined) { throw new TypeError(\u0026#39;Cannot convert undefined or null to object\u0026#39;) } target = Object(target) for (let nextObj of args) { for (let key in nextObj) { nextObj.hasOwnProperty(key) \u0026amp;\u0026amp; (target[key] = nextObj[key]) } } return target } const testa = { name: \u0026#39;林三心\u0026#39; } const testb = { name: \u0026#39;sunshine_lin\u0026#39;, age: 22 } const testc = { age: 18, gender: \u0026#39;男\u0026#39; } const testd = Object.sx_assign(testa, testb, testc) console.log(testd) // { name: \u0026#39;sunshine_lin\u0026#39;, age: 18, gender: \u0026#39;男\u0026#39; } console.log(testa === testd) // true Function篇\n46、call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Function.prototype.sx_call = function (obj, ...args) { obj = obj || window // Symbol是唯一的，防止重名key const fn = Symbol() obj[fn] = this // 执行，返回执行值 return obj[fn](...args) } const testobj = { name: \u0026#39;林三心\u0026#39;, testFn(age) { console.log(`${this.name}${age}岁了`) } } const testobj2 = { name: \u0026#39;sunshine_lin\u0026#39; } testobj.testFn.sx_call(testobj2, 22) // sunshine_lin22岁了 47、apply 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Function.prototype.sx_apply = function (obj, args) { obj = obj || window // Symbol是唯一的，防止重名key const fn = Symbol() obj[fn] = this // 执行，返回执行值 return obj[fn](...args) } const testobj = { name: \u0026#39;林三心\u0026#39;, testFn(age) { console.log(`${this.name}${age}岁了`) } } const testobj2 = { name: \u0026#39;sunshine_lin\u0026#39; } testobj.testFn.sx_apply(testobj2, [22]) // sunshine_lin22岁了 48、Function.prototype.bind 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /**难点： * * bind是返回一个函数，而不是执行结果 * bind返回的函数，拿来当做构造函数，该怎么处理 */ Function.prototype.sx_bind = function (obj, ...args) { obj = obj || window // Symbol是唯一的，防止重名key const fn = Symbol() obj[fn] = this const _this = this const res = function (...innerArgs) { console.log(this, _this) if (this instanceof _this) { this[fn] = _this this[fn](...[...args, ...innerArgs]) delete this[fn] } else { obj[fn](...[...args, ...innerArgs]) delete obj[fn] } } res.prototype = Object.create(this.prototype) return res } String篇\n49、slice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /**参数代表含义 * * start：开始截取的字符索引(包含此字符) * end：结束截取的字符索引(不包含此字符) 注意点 * start \u0026gt; end：返回空字符串 * start \u0026lt; 0：start = 数组长度 + start */ String.prototype.sx_slice = function (start = 0, end) { start = start \u0026lt; 0 ? this.length + start : start end = !end \u0026amp;\u0026amp; end !== 0 ? this.length : end if (start \u0026gt;= end) return \u0026#39;\u0026#39; let str = \u0026#39;\u0026#39; for (let i = start; i \u0026lt; end; i++) { str += this[i] } return str } console.log(str.sx_slice(2)) // nshine_lin console.log(str.sx_slice(-2)) // in console.log(str.sx_slice(-9, 10)) // shine_l console.log(str.sx_slice(5, 1)) // \u0026#39;\u0026#39; 50、substr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /**参数代表含义 * * start：开始截取的字符索引(包含此字符) * length：截取的长度 注意点 * start \u0026lt; 0：start = 数组长度 + start * length超出所能截取范围，需要做处理 * length \u0026lt; 0：返回空字符串 */ String.prototype.sx_substr = function (start = 0, length) { if (length \u0026lt; 0) return \u0026#39;\u0026#39; start = start \u0026lt; 0 ? this.length + start : start length = (!length \u0026amp;\u0026amp; length !== 0) || length \u0026gt; this.length - start ? this.length : start + length let str = \u0026#39;\u0026#39; for (let i = start; i \u0026lt; length; i++) { str += this[i] } return str } console.log(str.sx_substr(3)) // shine_lin console.log(str.sx_substr(3, 3)) // shi console.log(str.sx_substr(5, 300)) // ine_lin 51、substring 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 功能与slice大致相同 // 区别之处 // start \u0026gt; end：互换值 String.prototype.sx_sunstring = function (start = 0, end) { start = start \u0026lt; 0 ? this.length + start : start end = !end \u0026amp;\u0026amp; end !== 0 ? this.length : end if (start \u0026gt;= end) [start, end] = [end, start] let str = \u0026#39;\u0026#39; for (let i = start; i \u0026lt; end; i++) { str += this[i] } return str } console.log(str.sx_sunstring(2)) // nshine_lin console.log(str.sx_sunstring(-2)) // in console.log(str.sx_sunstring(-9, 10)) // shine_l console.log(str.sx_sunstring(5, 1)) // unsh Promise篇\n52、all 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 接收一个Promise数组，数组中如有非Promise项，则此项当做成功 // 如果所有Promise都成功，则返回成功结果数组 // 如果有一个Promise失败，则返回这个失败结果 function all(promises) { const result = [] let count = 0 return new MyPromise((resolve, reject) =\u0026gt; { const addData = (index, value) =\u0026gt; { result[index] = value count++ if (count === promises.length) resolve(result) } promises.forEach((promise, index) =\u0026gt; { if (promise instanceof MyPromise) { promise.then(res =\u0026gt; { addData(index, res) }, err =\u0026gt; reject(err)) } else { addData(index, promise) } }) }) } 53、race 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 接收一个Promise数组，数组中如有非Promise项，则此项当做成功 // 哪个Promise最快得到结果，就返回那个结果，无论成功失败 function race(promises) { return new MyPromise((resolve, reject) =\u0026gt; { promises.forEach(promise =\u0026gt; { if (promise instanceof MyPromise) { promise.then(res =\u0026gt; { resolve(res) }, err =\u0026gt; { reject(err) }) } else { resolve(promise) } }) }) } 54、allSettled 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 接收一个Promise数组，数组中如有非Promise项，则此项当做成功 // 把每一个Promise的结果，集合成数组，返回 function allSettled(promises) { return new Promise((resolve, reject) =\u0026gt; { const res = [] let count = 0 const addData = (status, value, i) =\u0026gt; { res[i] = { status, value } count++ if (count === promises.length) { resolve(res) } } promises.forEach((promise, i) =\u0026gt; { if (promise instanceof MyPromise) { promise.then(res =\u0026gt; { addData(\u0026#39;fulfilled\u0026#39;, res, i) }, err =\u0026gt; { addData(\u0026#39;rejected\u0026#39;, err, i) }) } else { addData(\u0026#39;fulfilled\u0026#39;, promise, i) } }) }) } 55、any 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // any与all相反 // 接收一个Promise数组，数组中如有非Promise项，则此项当做成功 // 如果有一个Promise成功，则返回这个成功结果 // 如果所有Promise都失败，则报错 function any(promises) { return new Promise((resolve, reject) =\u0026gt; { let count = 0 promises.forEach((promise) =\u0026gt; { promise.then(val =\u0026gt; { resolve(val) }, err =\u0026gt; { count++ if (count === promises.length) { reject(new AggregateError(\u0026#39;All promises were rejected\u0026#39;)) } }) }) }) } 56、finally 1 2 3 4 5 6 7 8 9 10 11 // 接收一个回调函数，但无参数接收 // 无论成功失败状态，都会执行finally Promise.prototype.finally = function(callback) { return this.then(res =\u0026gt; { callback() return res }, err =\u0026gt; { callback() throw err }) } ","permalink":"https://linlccc.com/posts/adv-js-knowledge/","summary":"1、实现原生的AJAX请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const ajax = { get(url, fn) { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;GET\u0026#39;, url, true)// 第三个参数异步与否 xhr.onreadystatechange = function() { if (xhr.readyState === 4) { fn(xhr.responeText) } } xhr.send() }, post(url, data, fn) { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;POST\u0026#39;, url, true) xhr.setRequestHeader(\u0026#39;Content-type\u0026#39;,\u0026#39;application/x-www-form-urlencoded\u0026#39;) xhr.onreadystatechange = function () { if (xhr.readyState === 4) { fn(xhr.responeText) } }","title":"手写js高级知识点"},{"content":"ES6 20个经常使用的技巧 打乱数组顺序 1 2 3 4 let arr = [\u0026#39;😄\u0026#39;, 67, true, false, \u0026#39;55\u0026#39;] arr = arr.sort(() =\u0026gt; 0.5 - Math.random()) console.log(arr) // [ \u0026#39;😄\u0026#39;, \u0026#39;55\u0026#39;, 67, false, true ] 删除数字之外的所有字符 1 2 3 4 const str = \u0026#39;xieyezi 23213 is 95994 so hansome 223333\u0026#39; const numbers = str.replace(/\\D/g, \u0026#39;\u0026#39;) console.log(numbers) // 2321395994223333 反转字符串或者单词 1 2 3 4 5 6 7 8 9 10 11 12 const sentence = \u0026#39;xieyezi js so handsome, lol.\u0026#39; const reverseSentence = reverseBySeparator(sentence, \u0026#34;\u0026#34;) console.log(reverseSentence); // .lol ,emosdnah os sj izeyeix const reverseEachWord = reverseBySeparator(reverseSentence, \u0026#34; \u0026#34;) console.log(reverseEachWord) // izeyeix sj os ,emosdnah .lol function reverseBySeparator(string, separator) { return string.split(separator).reverse().join(separator) } 将十进制转换为二进制文件或十六进制数 1 2 3 const num = 45 num.toString(2) num.tostring(16) 合并多个对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const city = { name: \u0026#39;Chongqing\u0026#39;, population: \u0026#39;1,234,567,890\u0026#39; } const location = { longitude: \u0026#39;116.4\u0026#39;, latitude: \u0026#39;39.9\u0026#39; } const fullCity = { ...city, ...location } console.log(fullCity) // { // name: \u0026#39;Chongqing\u0026#39;, // population: \u0026#39;1,234,567,890\u0026#39;, // longitude: \u0026#39;116.4\u0026#39;, // latitude: \u0026#39;39.9\u0026#39; // } === 和 == 的区别 1 2 3 4 5 6 7 8 9 // == -\u0026gt; 类型转换 (浅比较) // === -\u0026gt; 无类型转换 (严格比较) 0 == false // true 0 === false // false 1 == \u0026#34;1\u0026#34; // true 1 === \u0026#34;1\u0026#34; // false null == undefined // true null === undefined // false 解构赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const forest = { location: \u0026#39;Sweden\u0026#39;, animals: 3, animalsTypes: [\u0026#39;Lions\u0026#39;, \u0026#39;Tigers\u0026#39;, \u0026#39;Bears\u0026#39;], }; const { location, animals, animalsTypes } = forest; const [lions, tigers, bears] = animalsTypes; console.log(location); // Sweden console.log(animals); // 3 console.log(lions); // Lions console.log(tigers); // Tigers console.log(bears); // Bears 交换变量的值 1 2 3 4 5 let bears = \u0026#39;bears\u0026#39; let tigers = \u0026#39;tigers\u0026#39; [bears, tigers] = [tigers, bears] console.log(bears) // tigers console.log(tribes) // bears 判断回文字符串 1 2 3 4 5 6 7 8 9 10 11 const isRevervse = (str1, str2) =\u0026gt; { const normalize = (str) =\u0026gt; str.toLowerCase() .normalize(\u0026#39;NFD\u0026#39;) .split(\u0026#39;\u0026#39;) .reverse() .join(\u0026#39;\u0026#39;) return normalize(str1) === str2 } console.log(isRevervse(\u0026#39;anagram\u0026#39;, \u0026#39;margana\u0026#39;)) // true console.log(isRevervse(\u0026#39;rac\u0026#39;, \u0026#39;car\u0026#39;)) // true 回文字符串: 正着写和反着写都一样的字符串 (特别感谢@浮生阁阁主勘误)\n判断两个字符串是否为互相排列 1 2 3 4 5 6 7 8 9 10 11 12 const isAnagram = (str1, str2) =\u0026gt; { const normalize = (str) =\u0026gt; str.toLowerCase() .normalize(\u0026#39;NFD\u0026#39;) .split(\u0026#39;\u0026#39;) .sort() .join(\u0026#39;\u0026#39;) return normalize(str1) === normalize(str2) } console.log(isAnagram(\u0026#39;anagram\u0026#39;, \u0026#39;nagaram\u0026#39;)) // true console.log(isAnagram(\u0026#39;rat\u0026#39;, \u0026#39;car\u0026#39;)) // false console.log(isAnagram(\u0026#39;heArT\u0026#39;, \u0026#39;traEH\u0026#39;)) // true 判断两个字符串是否为互相排列: 给定两个字符串,一个是否是另一个的排列\n可选链操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 const player = { name: \u0026#39;xieyezi\u0026#39;, rating: 1000, click: () =\u0026gt; { return \u0026#39;click\u0026#39; }, pass: (teammate) =\u0026gt; { return `Pass to ${teammate}` }, } console.log(player?.name) // xieyezi console.log(player?.click?.()) // click console.log(player?.teammate?.()) // undefined 三目运算符 1 2 3 4 // condition ? expression if true : expression if false const oxygen = 10 const diver = (oxygen \u0026lt; 10 ) ? \u0026#39;Low oxygen\u0026#39; : \u0026#39;High oxygen\u0026#39; console.log(diver) // High oxygen 从数组中随机选择一个值 1 2 3 4 const elements = [24, \u0026#39;You\u0026#39;, 777, \u0026#39;breaking\u0026#39;, 99, \u0026#39;full\u0026#39;] const random = (arr) =\u0026gt; arr[Math.floor(Math.random() * arr.length)] const randomElement = random(elements) console.log(randomElement) // 777 冻结对象 1 2 3 4 5 6 7 const octopus = { tentacles: 8, color: \u0026#39;blue\u0026#39;, } Object.freeze(octopus) octopus.tentacles = 10 // Error, 不会改变 console.log(octopus) // { tentacles: 8, color: \u0026#39;blue\u0026#39;} 删除数组重复的元素 1 2 3 4 const animals = [\u0026#39;bears\u0026#39;, \u0026#39;lions\u0026#39;, \u0026#39;tigers\u0026#39;, \u0026#39;bears\u0026#39;, \u0026#39;lions\u0026#39;] const unique = (arr) =\u0026gt; [...new Set(arr)] console.log(unique(animals)) // [ \u0026#39;bears\u0026#39;, \u0026#39;lions\u0026#39;, \u0026#39;tigers\u0026#39; ] 保留指定位小数 1 2 3 4 5 6 const num = 0.123456789 const fixed2 = num.toFixed(2) const fixed3 = num.toFixed(3) console.log(fixed2) // 0.12 console.log(fixed3) // 0.123 清空数组 1 2 3 4 const numbers = [1, 2, 3, 4, 5] numbers.length = 0 console.log(numbers) // [] 从 RGB 转换为 HEX 1 2 3 4 5 6 7 8 const rgbToHex = (r, g, b) =\u0026gt; { const toHex = (num) =\u0026gt; { const hex = num.toString(16) return hex.length === 1 ? `0${hex}` : hex } return `#${toHex(r)}${toHex(g)}${toHex(b)}` } console.log(rgbToHex(46, 32, 67)) // #2e2043 从数组中获取最大值和最小值 1 2 3 4 5 const nums = [1, 2, 3, 4, 5, -3, 99, -45, -1] const max = Math.max(...nums) const min = Math.min(...nums) console.log(max) // 99 console.log(min) // -45 空值合并运算符 1 2 3 4 5 6 7 8 9 10 11 const nullval = null cost emptyString = \u0026#39;\u0026#39; const someNum = 13 const a = nullval ?? \u0026#39;A default\u0026#39; const b = emptyString ?? \u0026#39;B default\u0026#39; const c = SomeNum ?? \u0026#39;C default\u0026#39; console.log(a) // A default console.log(b) // \u0026#39;\u0026#39; // empty string != undefined or null console.log(c) // 13 过滤数组中值为 false 的值 1 2 3 const nums = [1, 0 , undefined, null, false]; const truthyNums = nums.filter(Boolean); console.log(truthyNums) // [1] ","permalink":"https://linlccc.com/posts/commonlyusedes6/","summary":"ES6 20个经常使用的技巧 打乱数组顺序 1 2 3 4 let arr = [\u0026#39;😄\u0026#39;, 67, true, false, \u0026#39;55\u0026#39;] arr = arr.sort(() =\u0026gt; 0.5 - Math.random()) console.log(arr) // [ \u0026#39;😄\u0026#39;, \u0026#39;55\u0026#39;, 67, false, true ] 删除数字之外的所有字符 1 2 3 4 const str = \u0026#39;xieyezi 23213 is 95994 so hansome 223333\u0026#39; const numbers = str.replace(/\\D/g, \u0026#39;\u0026#39;) console.log(numbers) //","title":"ES6 常用代码块"},{"content":"防抖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function debounce (fn, delay) { let timer; return function (...args) { timer\u0026amp;\u0026amp;clearTimeout(timer); timer = setTimeout(() =\u0026gt; fn.apply(this, args), delay); }; } // 测试 function task (arg) { console.log(\u0026#39;run task\u0026#39; + arg); } const debounceTask = debounce(task, 1000); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; debounceTask(11)); 节流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function throttle (fn, delay) { let last = 0; return function (...args) { const now = Date.now(); if (now - last \u0026lt; delay) return; last = now; fn.apply(this, args); }; } // 测试 function task () { console.log(\u0026#39;run task\u0026#39;); } const throttleTask = throttle(task, 1000); window.addEventListener(\u0026#39;scroll\u0026#39;, throttleTask); 深拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function deepClone (obj, cache = new WeakMap()) { if (typeof obj !== \u0026#39;object\u0026#39;) return obj; // 普通类型，直接返回 if (obj === null) return obj; if (cache.get(obj)) return cache.get(obj); // 防止循环引用，程序进入死循环 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 找到所属原型上的constructor，所属原型上的constructor指向当前对象的构造函数 let cloneObj = new obj.constructor(); cache.set(obj, cloneObj); // 缓存拷贝的对象，用于处理循环引用的情况 for (let key in obj) { if (obj.hasOwnProperty(key)) { cloneObj[key] = deepClone(obj[key], cache); // 递归拷贝 } } return cloneObj; } // 测试 const obj = { name: \u0026#39;Jack\u0026#39;, address: { x: 100, y: 200 } }; obj.a = obj; // 循环引用 const newObj = deepClone(obj); console.log(newObj.address === obj.address); // false 手写 Promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class MyPromise { constructor(executor) { // executor执行器 this.status = \u0026#39;pending\u0026#39;; // 等待状态 this.value = null; // 成功或失败的参数 this.fulfilledCallbacks = []; // 成功的函数队列 this.rejectedCallbacks = []; // 失败的函数队列 const that = this; function resolve (value) { // 成功的方法 if (that.status === \u0026#39;pending\u0026#39;) { that.status = \u0026#39;resolved\u0026#39;; that.value = value; that.fulfilledCallbacks.forEach(myFn =\u0026gt; myFn(that.value)); //执行回调方法 } } function reject (value) { //失败的方法 if (that.status === \u0026#39;pending\u0026#39;) { that.status = \u0026#39;rejected\u0026#39;; that.value = value; that.rejectedCallbacks.forEach(myFn =\u0026gt; myFn(that.value)); //执行回调方法 } } try { executor(resolve, reject); } catch (err) { reject(err); } } then (onFulfilled, onRejected) { if (this.status === \u0026#39;pending\u0026#39;) { // 等待状态，添加回调函数到成功的函数队列 this.fulfilledCallbacks.push(() =\u0026gt; { onFulfilled(this.value); }); // 等待状态，添加回调函数到失败的函数队列 this.rejectedCallbacks.push(() =\u0026gt; { onRejected(this.value); }); } if (this.status === \u0026#39;resolved\u0026#39;) { // 支持同步调用 console.log(\u0026#39;this\u0026#39;, this); onFulfilled(this.value); } if (this.status === \u0026#39;rejected\u0026#39;) { // 支持同步调用 onRejected(this.value); } } } // 测试 function fn () { return new MyPromise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { if (Math.random() \u0026gt; 0.6) { resolve(1); } else { reject(2); } }, 1000); }); } fn().then( res =\u0026gt; { console.log(\u0026#39;res\u0026#39;, res); // res 1 }, err =\u0026gt; { console.log(\u0026#39;err\u0026#39;, err); // err 2 }); 异步控制并发数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function limitRequest (urls = [], limit = 5) { return new Promise((resolve, reject) =\u0026gt; { const len = urls.length; let count = 0; // 当前进行到第几个任务 const start = async () =\u0026gt; { const url = urls.shift(); // 从数组中拿取第一个任务 if (url) { try { await axios.post(url); if (count == len - 1) { // 最后一个任务 resolve(); } else { count++; // 成功，启动下一个任务 start(); } } catch (e) { count++; // 失败，也启动下一个任务 start(); } } }; // 启动limit个任务 while (limit \u0026gt; 0) { start(); limit -= 1; } }); } // 测试 limitRequest([\u0026#39;http://xxa\u0026#39;, \u0026#39;http://xxb\u0026#39;, \u0026#39;http://xxc\u0026#39;, \u0026#39;http://xxd\u0026#39;, \u0026#39;http://xxe\u0026#39;]); 继承 ES5 继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function Parent (name) { this.name = name; } Parent.prototype.eat = function () { console.log(this.name + \u0026#39; is eating\u0026#39;); }; function Child (name, age) { Parent.call(this, name); this.age = age; } Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child; // 测试 let xm = new Child(\u0026#39;xiaoming\u0026#39;, 12); console.log(xm.name); // xiaoming console.log(xm.age); // 12 xm.eat(); // xiaoming is eating ES6 继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Parent { constructor(name) { this.name = name; } eat () { console.log(this.name + \u0026#39; is eating\u0026#39;); } } class Child extends Parent { constructor(name, age) { super(name); this.age = age; } } // 测试 let xm = new Child(\u0026#39;xiaoming\u0026#39;, 12); console.log(xm.name); // xiaoming console.log(xm.age); // 12 xm.eat(); // xiaoming is eating 数组排序 sort 排序 1 2 3 4 5 6 7 8 9 // 对数字进行排序，简写 const arr = [3, 2, 4, 1, 5]; arr.sort((a, b) =\u0026gt; a - b); console.log(arr); // [1, 2, 3, 4, 5] // 对字母进行排序，简写 const arr = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;]; arr.sort(); console.log(arr); // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] 冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function bubbleSort (arr) { let len = arr.length; for (let i = 0; i \u0026lt; len - 1; i++) { // 从第一个元素开始，比较相邻的两个元素，前者大就交换位置 for (let j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { let num = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = num; } } // 每次遍历结束，都能找到一个最大值，放在数组最后 } return arr; } //测试 console.log(bubbleSort([2, 3, 1, 5, 4])); // [1, 2, 3, 4, 5] 数组去重 Set 去重 1 2 cosnt newArr = [...new Set(arr)]; const newArr = Array.from(new Set(arr)); indexOf 去重 1 2 3 4 5 6 7 8 9 10 11 12 13 function resetArr (arr) { let res = []; arr.forEach(item =\u0026gt; { if (res.indexOf(item) === -1) { res.push(item); } }); return res; } // 测试 const arr = [1, 1, 2, 3, 3]; console.log(resetArr(arr)); // [1, 2, 3] 获取 url 参数 URLSearchParams 方法 1 2 3 4 // 创建一个URLSearchParams实例 const urlSearchParams = new URLSearchParams(window.location.search); // 把键值对列表转换为一个对象 const params = Object.fromEntries(urlSearchParams.entries()); split 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function getParams (url) { const res = {}; if (url.includes(\u0026#39;?\u0026#39;)) { const str = url.split(\u0026#39;?\u0026#39;)[1]; const arr = str.split(\u0026#39;\u0026amp;\u0026#39;); arr.forEach(item =\u0026gt; { const key = item.split(\u0026#39;=\u0026#39;)[0]; const val = item.split(\u0026#39;=\u0026#39;)[1]; res[key] = decodeURIComponent(val); // 解码 }); } return res; } // 测试 const user = getParams(\u0026#39;http://www.baidu.com?user=%E9%98%BF%E9%A3%9E\u0026amp;age=16\u0026#39;); console.log(user); // { user: \u0026#39;阿飞\u0026#39;, age: \u0026#39;16\u0026#39; } 发布订阅模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class EventEmitter { constructor() { this.cache = {}; } on (name, fn) { if (this.cache[name]) { this.cache[name].push(fn); } else { this.cache[name] = [fn]; } } off (name, fn) { const tasks = this.cache[name]; if (tasks) { const index = tasks.findIndex((f) =\u0026gt; f === fn || f.callback === fn); if (index \u0026gt;= 0) { tasks.splice(index, 1); } } } emit (name, once = false) { if (this.cache[name]) { // 创建副本，如果回调函数内继续注册相同事件，会造成死循环 const tasks = this.cache[name].slice(); for (let fn of tasks) { fn(); } if (once) { delete this.cache[name]; } } } } // 测试 const eventBus = new EventEmitter(); const task1 = () =\u0026gt; { console.log(\u0026#39;task1\u0026#39;); }; const task2 = () =\u0026gt; { console.log(\u0026#39;task2\u0026#39;); }; eventBus.on(\u0026#39;task\u0026#39;, task1); eventBus.on(\u0026#39;task\u0026#39;, task2); eventBus.off(\u0026#39;task\u0026#39;, task1); setTimeout(() =\u0026gt; { eventBus.emit(\u0026#39;task\u0026#39;); // task2 }, 1000); ","permalink":"https://linlccc.com/posts/commonlyusedjs/","summary":"防抖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function debounce (fn, delay) { let timer; return function (...args) { timer\u0026amp;\u0026amp;clearTimeout(timer); timer = setTimeout(() =\u0026gt; fn.apply(this, args), delay); }; } // 测试 function task (arg) { console.log(\u0026#39;run task\u0026#39; + arg); } const debounceTask = debounce(task, 1000); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; debounceTask(11)); 节流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function throttle (fn, delay) { let last = 0; return function (...args) { const now = Date.now(); if (now - last \u0026lt; delay) return;","title":"常用js"},{"content":"具体配置可见 NGINX 配置\nNGINX 入门学习笔记\nNGINX 备忘清单\nWeb服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # http server { listen 80; server_name _; location / { root /data; index index.html index.htm; } } # https server { listen 443 ssl; server_name _; ssl_certificate /path/to/certificete.crt; ssl_certificate_key /path/to/private-key.key; location / { root /data; index index.html index.htm; } } 反向代理 1 2 3 4 5 6 7 8 9 server { listen 80; server_name _; location / { proxy_pass http://192.168.241.11; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } 负载均衡 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 upstream web { ip_hash #会话保持 server 192.168.241.22; server 192.168.241.23; } server { listen 80; server_name _; location / { proxy_pass http://web; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } 重定向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 老域名跳转新域名 server { listen 80; server_name old.cxk.cn; location / { rewrite ^/(.*)$ https://new.cxk.cn/$1; } } # 路径重定向 server { listen 80; server_name old.cxk.cn; location / { rewrite ^/old.cxk.cn/(.*)$ /new-path/$1; } } 防盗链 1 2 3 4 5 6 7 8 9 10 server { listen 80; server_name _; location ~* \\.(gif|jpg|jpeg|png) { valid_referers none blocked *.cxk.cn; if ($invalid_referer) { return 403; } } } 手机端重定向PC 1 2 3 4 5 6 7 8 9 server { listen 80; server_name _; location / { if ($http_user_agent ~* \u0026#39;(android|iphone|ipad)\u0026#39;) { return ^/(.*)$ https://yd.cxk.cn/$1; } } } 基于请求路径转发不同服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 80; server_name _; location / { proxy_pass http://192.168.241.11; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; } location /beijing { proxy_pass http://192.168.241.22; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; } location /nanjing { proxy_pass http://192.168.241.23; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; } } ","permalink":"https://linlccc.com/posts/nginxconfig/","summary":"具体配置可见 NGINX 配置 NGINX 入门学习笔记 NGINX 备忘清单 Web服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # http server { listen 80; server_name _; location / { root /data; index index.html index.htm; } } # https server { listen 443 ssl; server_name _; ssl_certificate /path/to/certificete.crt; ssl_certificate_key /path/to/private-key.key; location / { root /data; index index.html index.htm; } } 反向代理 1 2 3 4 5 6 7","title":"Nginx基础配置"},{"content":"DCL(Data Control Language)数据控制语言 DCL 在 mysql 中可以正常使用其他数据库没测试 用户管理 1 2 3 4 5 6 -- 查询用户 select host,user from mysql.user; -- 添加用户 create user \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; identified by \u0026#39;密码\u0026#39;; -- 删除用户 drop user \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; 权限管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 查询权限 show grants for \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; -- 查询 root 用户权限 show grants for \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; -- 给予权限 grant 权限列表 on 库名.表名 to \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; -- 给 user1 授予所有权限 grant all on *.* to \u0026#39;user1\u0026#39;@\u0026#39;localhost\u0026#39;; -- 撤销权限 revoke 权限列表 on 库名.表名 from \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; -- 撤销 user1 的所有权限 revoke all on *.* from \u0026#39;user1\u0026#39;@\u0026#39;localhost\u0026#39;; DDL(Data Definition Language)数据定义语言 操作库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 查看所有数据库 show databases; -- 查看数据库的定义信息 show create database 库名; -- 创建库 create database 库名; -- 检查库是否存在，不存在则创建 create database if not exists 库名; -- 修改数据库字符信息 alter database 库名 character set utf8; -- 删除数据库 drop database 库名; 操作表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- 查看表结构 desc 表名; -- 查看创建表的SQL语句 show create table 表名; -- 创建表 create table 表名( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); -- 修改表名 alter table 旧表名 rename to 新表名; -- 删除表 drop table 表名; -- 检查表是否存在，存在则删除 drop table if exists 表名; -- 添加一列 alter table 表名 add 列名 数据类型; -- 删除列 alter table 表名 drop 列名; DML(Data Manipulation Language)数据操作语言 插入 insert into 1 2 3 4 -- 写列名 insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); -- 不写列名 insert into 表名 values(值1,值2,...值n); 删除 delete 1 2 3 4 5 6 -- 删除表中数据 delete from 表名 where 列名 = 值; -- 删除表中所有数据 delete from 表名; -- 删除表中所有数据（直接删除表，再创建一张一样的表） truncate table 表名; 修改 update 1 2 3 4 -- 不带条件的修改(修改所有行) update 表名 set 列名 = 值; -- 带条件的修改 update 表名 set 列名 = 值 where 列名 = 值; DQL(Data Query Language)数据查询语言 基础关键字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 -- 查询年龄大于等于20 小于等于30 -- \u0026amp;\u0026amp;(并且) select * from 表名 where age \u0026gt;= 20 \u0026amp;\u0026amp; age \u0026lt;= 30; -- and(并且) select * from 表名 where age \u0026gt;= 20 and age \u0026lt;= 30; -- between..and(之间) select * from 表名 where age between 20 and 30; -- 查询年龄22岁，18岁，25岁的信息 -- or(或者) select * from 表名 where age = 22 or age = 18 or age = 25; -- in(集合) select * from 表名 where age in (22,18,25); -- 查询英语成绩不为null -- in not null(不为空) select * from 表名 where english is not null; /** like(模糊查询) _(单个字符) %(多个字符) */ -- 查询性王的人 select * from 表名 where name like \u0026#39;王%\u0026#39;; -- 查询第二个字是麻的人 select * from 表名 where name like \u0026#39;_麻%\u0026#39;; -- 查询名字是三个字的人 select * from 表名 where name like \u0026#39;___\u0026#39;; -- distinct(重复的值都只显示一个) -- 查询年龄集合，重复的只显示一个 select distinct age where 表名; 排序查询 1 2 3 4 -- 根据年龄升序(默认) select * from 表名 order by age; -- 根据年龄降序 select * from 表名 order by age desc; 聚合函数 1 2 3 4 5 6 7 8 9 10 -- 计算数据行数 select max(*) from 表名; -- 计算年龄最大是多少 select max(age) from 表名; -- 计算年龄最小是多少 select min(age) from 表名; -- 计算年龄总和是多少 select sum(age) from 表名; -- 计算年龄平均数是多少 select avg(age) from 表名; 分组查询 group by 1 2 3 4 5 6 -- 按照性别分组,分别查询男、女的平均分、人数 select sex,avg(math),count(id) from 表名 group by sex; -- 将分数高于60的人按照性别分组,分别查询男、女的平均分、人数 select sex,avg(math),count(id) from 表名 where math \u0026gt; 60 group by sex; -- 按照性别分组,分别查询男、女的平均分、人数。要求：分数大于60，分组后人数大于2 select sex,avg(math),count(id) from 表名 where math \u0026gt; 60 group by sex having count(id) \u0026gt; 2; 分页查询 1 2 3 4 5 6 7 8 9 10 11 12 /** 该分页只支持mysql limit 开始索引,查询条数 开始索引计算公式：(页数 - 1) * 每页条数 */ -- 每页显示10条 -- 第一页 select * from 表名 limit 0,10; -- 第二页 select * from 表名 limit 10,10; -- 第三页 select * from 表名 limit 20,10; 内连接查询 1 2 3 4 5 6 7 8 9 10 11 -- 隐式内连接 -- 语法 select 字段列表 from 表1,表2...表n where 条件; -- 例子 select t1.c1,t1.c2,t2.c1 from t1,t2 where t1.t2Id = t2.id; -- 显式内连接 -- 语法 select 字段列表 from 表1 join 表2 on 条件; -- 例子 select * from t1 join t2 on t1.t2Id = t2.id; 外连接查询 1 2 3 4 5 6 7 8 9 10 11 -- 左外连接 -- 语法 select 字段列表 from 表1 left join 表2 on 条件; -- 例子 select t1.*,t2.c1 from t1 left join t2 ON t1.t2Id = t2.id; -- 右外连接 -- 语法 select 字段列表 from 表1 right join 表2 on 条件; -- 例子 select t1.*,t2.c1 from t1 right join t2 ON t1.t2Id = t2.id; 子查询 子查询结果是单行单列 1 2 3 4 5 6 -- 查询最高的成绩（这里假设最高为98） select max(math) from 表名; -- 查询成绩最高的人的信息 select * from 表名 where math = 98; -- 使用子查询 select * from 表名 where math = (select max(math) from 表名); 子查询结果是多行单列 1 2 3 4 5 6 -- 查询名称为n1或者n2的id（这里假设id为1，2） select id from 表名 where name = \u0026#39;n1\u0026#39; or name = \u0026#39;n2\u0026#39;; -- 查询成绩最高的人的信息 select * from 表名 where id = 1 or id = 2; -- 使用子查询 select * from 表名 where id in (select id from 表名 where name = \u0026#39;n1\u0026#39; or name = \u0026#39;n2\u0026#39;); 子查询结果是多行多列 1 2 -- 这里t1和t2是同一张表，查询结果每列有两个相同的数据 select * from 表名 t1,(select * from 表名) t2 where t1.id = t2.id; ","permalink":"https://linlccc.com/posts/commonsql/","summary":"DCL(Data Control Language)数据控制语言 DCL 在 mysql 中可以正常使用其他数据库没测试 用户管理 1 2 3 4 5 6 -- 查询用户 select host,user from mysql.user; -- 添加用户 create user \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; identified by \u0026#39;密码\u0026#3","title":"常用SQL"},{"content":"系统指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 显示系统信息：内核版本、机器类型等 uname # 显示正在运行的Linux内核的发行版本 uname -r # 显示当前时间、系统运行时间、用户和负载平均值 uptime # 显示系统主机名 hostname # 显示当前主机的ip地址 hostname -i # 查看系统最近一次的重启时间以及重启之前的系统登录信息 last reboot # 显示当前日期和时间 date # 设置系统时间与日期 timedatectl # 快速查看当前/指定年份日历 cal # 显示目前登入系统的用户信息 w # 显示当前用户的用户名 whoami # 显示名为\u0026#34;username\u0026#34;的用户的信息 finger username 文件命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 以长格式列出所有文件的详细信息 ls -al # 显示当前工作目录的路径 pwd # 创建一个名为 dir1 的新目录 mkdir dir1 # 删除名为 file1 的文件 rm file1 # 强制删除名为 file2 的文件 rm -f file2 # 递归删除目录 dir1 及其内容 rm -r dir1 # 强制删除目录 dir1 及其内容 rm -rf dir1 # 复制 file1,创建或覆盖 file2 cp file1 file2 # 将 dir1 复制到 dir2,包括子目录 cp -r dir1 dir2 # 将 file1 重命名或移动到 file2 mv file1 file2 # 创建名为 linkName 到 fileName 的符号链接 ln -s /oath/to/fileName linkName # 创建一个名为 file1 的空文件 touch file1 # 创建/覆盖 file1,等得标准输入 cat \u0026gt; file1 # 逐页显示们 file1 的内容 more file1 # 显示 file1 的前十行 head file1 # 显示 file1 的最后十行 tail file1 # 使用对称密码对 file1 进行加密,需要提供密码短语 gpg -c file1 # 解密 file2.gpg,提示输入密码 gpg file2.gpg # 统计文件中的字数、行数和字符数 wc # 使用管道或文件提供的参数执行命令 xargs 用户管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 显示用户的UID、GID、组 id # 显示最后登录用户的列表 last # 显示当前登录的用户 who # 创建一个名为 Admin 的新用户组 groupadd admin # 创建一个名为 Sam 的新用户组 adduser Sam # 删除名为 Sam 的用户 userdel Sam # 修改现有用户的属性 usermod 硬件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 内核会将开机过程信息存储在环形缓冲区中 dmesg # 显示 CPU 的详细信息 cat/proc/cpuinfo # 显示详细的系统内存使用信息 cat/proc/meminfo # 列出系统的详细硬件配置 lshw # 列出所有可用的块设备的信息 lsblk # 显示系统内存使用情况 free -m # 以树状格式详细显示 PCI 设备信息 lspci -tv # 以树状格式详细显示 USB 设备信息 lsusb -tv # 显示系统 BIOS 中的硬件信息 dmidecode # 显示磁盘 /dev/sda 的信息 hdparm -i /dev/sda # 用于检查设备 /dev/sda 是否存在坏块,并显示检测进度 badblocks -s /dev/sda 登录 1 2 3 4 5 6 7 8 # 向指定主机名发起 SSH 连接 ssh user@hostname # 使用特定端口发起 SSH 连接 ssh -p portNumber user@hostname # 通过 telnet 连接到主机的默认端口 23 Connect to the host via telnet default port 23 # 通过l elnet 默认端口23连接到主机 telnet host 安装包 1 2 3 4 5 6 7 8 # 使用 RPM 包管理器安装 pkgName.rpm 包 rpm -i pkgName.rpm # 卸载指定的 RPM 包 rpm -e pkgName # 使用 DNF 安装指定的包， dnf install pkgName # 使用 Pacman 安装指定的包 pacman -S 安装源（编译） 1 2 3 4 5 6 # 检查系统兼容性并生成用于软件安装的 makefile ./configure # 按照 makefoile 中的指令编译代码 make # 将编译后的代码安装到指定的系统位置 make install 目录遍历 1 2 3 4 5 6 # 切换到父目录 cd .. # 将当前目录更改为用户的主目录 cd # 将当前目录更改为\u0026#34;/mnt\u0026#34; cd /mnt 流程相关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 显示当前进程的快照 ps # 显示运行中的 tolnet 进程的详细信息 ps aux | grep telnet # 显示进程的内存映射 pmap # 显示运行任务的动态实时视图 top # 终止具有 PID 1234 的进程 kill 1234 # 终止所有名为\u0026#39;proc\u0026#39; 的进程 killall proc # 终止具有指定名称的进程 pkill processName # 在后台恢复暂停的作业 bg # 将暂停的作业带到前台 fg # 将作业编号为\u0026#39;n\u0026#39; 的作业移到前台运行 fg n # 列出所有打开的文件和进程 lsof # 更改具有给定 PID 的进程的优先级 renice 19 PID # 显示firefox 进程的进程ID pgrep firefox # 显示运行中的进程树 pstree 网络 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 显示所有网络接口及其信息 ip addr show # 将 IP 地址 192.168.0.1 分配给eth0接口 ip address add 192.168.0.1/24 dev eth0 # 显示网络接口及其配置 ifconfig # 发送 ICMP 数据包,测量与 host 之问的往返时间 ping host # 检索并显示域名的注册信息 whois domain # 查询 DNS,提供域名的 DNS 信息 dig domain # 将 IP 地址解析为主机名,显示 DNS 信息 dig -x host # 对域名进行 IP 查找 host gexample.com # 从指定路径下载文件 wget flePath # 显示各种与网络相关的信息和统计数据 netstat 磁盘使用情况 1 2 3 4 5 6 7 8 9 10 11 12 # 显示所有已挂载文件系统可读的磁盘空问使用情况 df -h # 显示所有已挂载文件系统的 inode 使用情况 df -i # 列出所有驱动器上的分区及其信息 fdisk -l # 显示 /dir1 目录的总磁盘使用大小的摘要,以可读方式呈现 du -sh/dir1 # 显示所有已挂载文件系统及其属性的列表 findmnt # 将设备挂载到指定的文件系统挂载点上 mount devicePath mountPoint 压缩/存档 1 2 3 4 5 6 7 8 # 创建一个名为 backup.tar 的 tar 归档文件,其中包含 /home/ubuntu 目录的内容 tar -cf backup.tar/home/ubuntu # 从 backup.tar 归档文件中提取文件 tar -xf backup.tar # 创建一个名为 backup.tar.gz 的压缩 tar 归档文件,其中包含 /home/ubuntu 目录的内容 tar -zcvf backup.tar.gz/home/ubuntu # 将文件 file1 压缩为 file1.gz,并删除原始文件 gzip file1 日志文件传输 1 2 3 4 5 6 # 将们 file.txt 复制到远程主机的指定目录 scp file.txt remoteuser@remoteHost:/remote/diroctory # 将源目录的内容同步到目标目录,保留属性 rsync -a /home/ubuntu/backup/ # 同步本地目录到远程,保留属性 rsync -a /var/www/web/user@remoteHost:/backup/webBackup/ 搜索 1 2 3 4 5 6 7 8 9 10 # 在文件中搜索给定的模式 grep pattern file # 在 dir1 目录及其子目录中递归搜索指定的 pattern grep -r pattern dir1 # 使用预建的数据库查找名为 file 的文件 locate file # 递归搜索 /home 目录中名为 index 的文件 find /homeName index # 在 /home 目录中查找大小超过 10000k 的文件 find /homeSize +10000k 文件权限 1 2 3 4 5 6 7 8 # 设置文件/data的权限为所有者读/写,组和其他人只读 chmod 644 /data/ # 将目录 /dir1 的权限设置为对所有者可读可写/可执行,对组和其他用户可读/可执行 chmod 755 /dir1 # 将文件 filename 的所有者更改为 bob 并将所属组更改为 devops chown bob:devops filename # 更改目录的所有者和所属组 chown ownername ","permalink":"https://linlccc.com/posts/linuxcommandlist/","summary":"系统指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 显示系统信息：内核版本、机器类型等 uname # 显示正在运行的Linux内核的发行版本 uname -r # 显示当前时间、系统运行时间、用户和负载平均值 uptime # 显示系统主机","title":"Linux 命令大全"},{"content":"生成新的 SSH 密钥 在终端中输入以下指令以提供的电子邮件为标签创建SSH密钥 1 ssh-keygen -t rsa -b 4096 -C \u0026#34;[email@example.com]\u0026#34; 根据提示输入密钥保存文件，可空保存到默认文件C:\\Users\\[User]\\.ssh\\id_rsa 根据提示输入两次密码（建议不设置密码，否者每次push都需要输入密码） 将 SSH 密钥添加到 ssh-agent 以管理员权限打开 PowerShell 启动 ssh agent: 1 2 Get-Service -Name ssh-agent | Set-Service -StartupType Manual Start-Service ssh-agent 将 SSH 私钥添加到 ssh-agent (无需管理员权限) 1 ssh-add C:\\Users\\[User]\\.ssh\\id_rsa 移除 SSH 密钥 删除C:\\Users\\[User]\\.ssh\\文件夹中的两个密钥文件 从ssh agent中移除ssh密钥 1 2 3 4 # 查看已加载的密钥列表 ssh-add -l # 移除密钥 ssh-add -d C:\\Users\\[User]\\.ssh\\id_rsa ","permalink":"https://linlccc.com/posts/managessh/","summary":"生成新的 SSH 密钥 在终端中输入以下指令以提供的电子邮件为标签创建SSH密钥 1 ssh-keygen -t rsa -b 4096 -C \u0026#34;[email@example.com]\u0026#34; 根据提示输入密钥保存文件，可空保存到默认文件C:\\Users\\[User]\\.ssh\\id_rsa 根据提示输入两次","title":"管理 SSH"},{"content":"基础 整数类型 这些类型里面除了只有 signed 和 int 的都可以省略 signed / int 例如 short, short int, signed short, signed short int 表示一个类型\n类型 占用字节数 取值范围 signed char 1 -128 到 127 unsigned char 1 0 到 255 short, short int, signed short, signed short int 2 -32768 到 32767 unsigned short, unsigned short int 2 0 到 65535 int, signed, signed int 4 -2147483648 到 2147483647 unsigned, unsigned int 4 0 到 4294967295 long, long int, signed long, signed long int 4 与 int 或 long long 相同 unsigned long, unsigned long int 4 与 unsigned 或 unsigned long long 相同 long long, long long int, signed long long, signed long long int 8 -9223372036854775808 到 9223372036854775807 unsigned long long, unsigned long long int 8 0 到 18446744073709551615 浮点类型 类型 占用字节数 取值范围 float 4 1.175494351e-38 到 3.402823466e+38 double 8 2.2250738585072014e-308 到 1.7976931348623157e+308 long double 12 3.36210314311209350626267781732175260e-4932 到 1.18973149535723176508575932662800702e+4932 无效浮点数信息 在C++中，浮点数类型的值可以是无效的，具体取决于浮点数类型的规范。以下是一些常见的无效浮点数值：\nNaN (Not a Number): 表示无效的计算结果，例如 0.0 / 0.0、sqrt(-1) 等，它可以用 std::numeric_limits\u0026lt;T\u0026gt;::quiet_NaN() 来表示。 Inf (Infinity): 表示除以 0 或者取 log(0) 等无穷值的结果，它可以用 std::numeric_limits\u0026lt;T\u0026gt;::infinity() 来表示。 -Inf (Negative Infinity): 表示除以 -0 或者取 log(-0) 等负无穷值的结果，它可以用 -std::numeric_limits\u0026lt;T\u0026gt;::infinity() 来表示。 denormalized number: 非规格化数，它是一个非零的非规格化浮点数W，不同于规格化数它的指数部分全是 0。在一些平台上，它可能会被截断成 0。 在 C++ 标准库中，可以使用 std::numeric_limits\u0026lt;T\u0026gt; 类模板来获取特定浮点数类型 T 的限制信息，例如 std::numeric_limits\u0026lt;double\u0026gt;::quiet_NaN() 就可以得到 double 类型的 NaN。\n无效浮点数操作 操作 结果 ±value/0 ±Infinity ±Infinity ± value ±Infinity ±Infinity * value ±Infinity ±Infinity / value ±Infinity 0 / 0 NaN ±Infinity / ±Infinity NaN Infinity - Infinity NaN Infinity * 0 NaN 数字字面量 类型 示例 int 42, -123 unsigned int 42u, 123U long 123456L, -123L unsigned long 123456ul, 123ul long long 123456789LL, -123LL unsigned long long 123456789ull, 123ull float 3.14f, -2.5F double 3.14, -2.5 long double 3.14L, -2.5L 进制表示方式 进制 表示方式 示例 二进制 以 0b 或 0B 开头 0b110 八进制 以 0 开头 017 10进制 直接输入数字 123 16进制 以 0x 或 0X 开头 0x1A sizeof 运算符 sizeof(type)：获取类型 type 的大小，返回 size_t 类型的值。 sizeof expression：获取表达式 expression 的大小，返回 size_t 类型的值。 sizeof...：获取模板参数包中元素的个数，返回 size_t 类型的值。这个用法通常用于可变参数模板。 1 2 3 4 5 6 7 8 9 10 11 12 13 // 获取类型的大小 std::cout \u0026lt;\u0026lt; \u0026#34;sizeof(int): \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 获取表达式的大小 int arr[] = {1, 2, 3}; std::cout \u0026lt;\u0026lt; \u0026#34;sizeof(arr): \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 获取模板参数包中元素的个数 template\u0026lt;typename... Ts\u0026gt; void foo(Ts... args) { std::cout \u0026lt;\u0026lt; \u0026#34;sizeof...(args): \u0026#34; \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } foo(1, \u0026#39;a\u0026#39;, 3.14); // 输出 \u0026#34;sizeof...(args): 3\u0026#34; 数值的上下限 std::numeric_limits\u0026lt;T\u0026gt; 类模板提供了获取数值类型 T 的上下限的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 在整数类型中 min 和 lowest 都是相同的，都是最小值 // 获取 int 类型的上限 std::numeric_limits\u0026lt;int\u0026gt;::max(); // 获取 int 类型的下限 std::numeric_limits\u0026lt;int\u0026gt;::min(); // 以下方法也可以获取下限 std::numeric_limits\u0026lt;int\u0026gt;::lowest(); // 在浮点数类型中，min 和 lowest 不同，min 得到的是最小的正整数，lowest 得到的才是最小的值 // 获取 float 类型的上限（3.40282e+38） std::numeric_limits\u0026lt;float\u0026gt;::max(); // 获取 float 类型的最小的正整数（1.17549e-38） std::numeric_limits\u0026lt;float\u0026gt;::min(); // 获取 float 类型的下限（-3.40282e+38） std::numeric_limits\u0026lt;float\u0026gt;::lowest(); char 、 wchar_t 、 char8_t 、 char16_t 、 char32_t 以上几种都是原生字符类型，用于表示数字、字母、符号等字符。\nchar:\n占用一个字节（8 位） 用于表示单个 8 位字符，即 ASCII 码表中的字符，范围是 0~127 在 C++ 中使用最为广泛，可以用于表示 ANSI 编码和 UTF-8 编码的字符，建议在表示 ASCII 字符时使用。 wchar_t:\n在不同平台上占用的字节数不同，通常为 2 个字节（16 位）或 4 个字节（32 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 在处理 Unicode 字符或多语言环境下有更好的应用场景，建议在需要处理 Unicode 字符时使用。 在些跨平台代码是不建议使用，因为不同平台上的 wchar_t 占用的字节数不同。 char8_t:\n占用一个字节（8 位） 用于表示单个 8 位字符，范围是所有 Unicode 字符中的 ASCII 码表部分，即 0~127 用于表示 UTF-8 编码的字符，建议在需要处理 UTF-8 编码的字符时使用。 char16_t:\n占用两个字节（16 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 用于表示 UTF-16 编码的字符，建议在需要处理 UTF-16 编码的字符时使用。 char32_t:\n占用四个字节（32 位） 用于表示单个 Unicode 字符，范围是所有 Unicode 字符 用于表示 UTF-32 编码的字符，建议在需要处理 UTF-32 编码的字符时使用。 变量初始化赋值 在C++中初始化赋值有三种方式\n建议平时使用花括号表示法，避免隐式类型转换，如果类型不匹配会报错，以达到更好的代码可读性和可维护性 赋值表示法和函数表示法在初始化时不会进行类型检查，如果类型不匹配会进行隐式类型转换（缩窄转换） 赋值表示法和函数表示法在进行缩窄转换时，大多数编译器会发出数据丢失的警告 1 2 3 4 int i = 0; // 赋值表示法 int j(0); // 函数表示法 int k{0}; // 花括号表示法 int l{}; // 这里是默认赋值为0 显示类型转换 类型转换方式 示例 建议使用方式 C风格类型转换 (float) x 不建议使用 静态/强制类型转换 static_cast\u0026lt;float\u0026gt;(x) 建议使用 重新解释类型的转换 reinterpret_cast\u0026lt;float\u0026gt;(x) 转换指针类型时建议使用 旧式的类型转换 float(x) 不建议使用 格式化字符串 std::format std::format 是 C++20 中的新特性，它提供了一种新的字符串格式化方式。该特性可以用来将多种类型的值格式化为字符串，并且支持多种格式控制符，可以更加灵活地控制输出格式。 这里列出格式说明符的一般形式：{[arg_id][:[[fill]align][sign][\u0026quot;#\u0026quot;][\u0026quot;0\u0026quot;][width][\u0026quot;.\u0026quot; precision][\u0026quot;L\u0026quot;][type]]}\narg_id：表示参数的索引, 从 0 开始\nfill：指定填充字符，可以是任意字符。如果省略，则默认为空格。\n1 2 std::format(\u0026#34;|{:\u0026lt;10}|\u0026#34;, \u0026#34;hello\u0026#34;); // |hello | std::format(\u0026#34;|{:*\u0026lt;10}|\u0026#34;, \u0026#34;hello\u0026#34;); // |hello*****| align：指定对齐方式，可以是以下几种：\n\u0026lt;：左对齐。 \u0026gt;: 右对齐。 ^: 居中对齐。 1 2 3 std::format(\u0026#34;|{:\u0026lt;10}|\u0026#34;, \u0026#34;hello\u0026#34;); // |hello | std::format(\u0026#34;|{:\u0026gt;10}|\u0026#34;, \u0026#34;hello\u0026#34;); // | hello| std::format(\u0026#34;|{:^10}|\u0026#34;, \u0026#34;hello\u0026#34;); // | hello | sign：指定符号显示方式，可以是以下几种：\n+：显示正号和负号。 -：只显示负号。 ``（空格）：在正数前面加空格，负数前面加负号（默认）。 1 2 3 4 5 std::format(\u0026#34;|{:+}|\u0026#34;, 10); // |+10| std::format(\u0026#34;|{:+}|\u0026#34;, -10); // |-10| std::format(\u0026#34;|{:-}|\u0026#34;, -10); // |-10| std::format(\u0026#34;|{: }|\u0026#34;, 10); // | 10| std::format(\u0026#34;|{: }|\u0026#34;, -10); // |-10| #：指定转换类型，可以是以下几种：\nb 或 B：二进制。 o 或 O：八进制。 x 或 X：十六进制。 e 或 E：科学计数法。 f 或 F：浮点数（默认）。 g 或 G：自动选择 f 或 e。 a 或 A：十六进制浮点数。 1 2 3 4 5 6 7 std::format(\u0026#34;|{:#x}|\u0026#34;, 255); // |0xff| std::format(\u0026#34;|{:#X}|\u0026#34;, 255); // |0xFF| std::format(\u0026#34;|{:#b}|\u0026#34;, 255); // |0b11111111| std::format(\u0026#34;|{:#o}|\u0026#34;, 255); // |0377| std::format(\u0026#34;|{:.2e}|\u0026#34;, 123.456); // |1.23e+02| std::format(\u0026#34;|{:.2f}|\u0026#34;, 123.456); // |123.46| std::format(\u0026#34;|{:.2g}|\u0026#34;, 123.456); // |1.2e+02| width：指定输出宽度，如果输出的字符串宽度小于指定的宽度，则会在左侧或右侧填充指定字符。\n.precision：指定浮点数输出的精度，即小数点后保留的位数\n常用转义字符 转义字符 含义 \\n 换行符（windows中是\\r\\n） \\r 回车符 \\t 垂直制表符 \\v 水平制表符 \\ 反斜杠 ' 单引号 \u0026quot; 双引号 常用预处理指令 预处理指令 含义 #if 用于条件编译，如果条件为真，则编译后面的代码，否则跳过后面的代码 #ifdef 用于条件编译，如果宏定义了，则编译后面的代码，否则跳过后面的代码 #ifndef 用于条件编译，如果宏没有定义，则编译后面的代码，否则跳过后面的代码 #else 用于条件编译，如果条件为假，则编译后面的代码，否则跳过后面的代码 #endif 用于条件编译，结束条件编译，与 #if 配对使用 #define 用于定义宏，可以用于条件编译，也可以用于替换代码中的字符串 #undef 用于取消宏定义，与 #define 配对使用 #error 用于输出错误信息，编译时会报错 #line 用于指定行号，与 #file 配对使用 #file 用于指定文件名，与 #line 配对使用 #pragma 用于指定编译器的行为，如指定编译器忽略警告 ","permalink":"https://linlccc.com/posts/cppstudynotes/","summary":"基础 整数类型 这些类型里面除了只有 signed 和 int 的都可以省略 signed / int 例如 short, short int, signed short, signed short int 表示一个类型 类型 占用字节数 取值范围 signed char 1 -128 到 127 unsigned char 1 0 到 255 short, short int, signed short, signed short int 2 -32768 到 32767 unsigned short, unsigned short int 2 0 到 65535 int, signed, signed int 4 -2147483648 到 2147483647 unsigned, unsigned int 4","title":"C++ 学习笔记"},{"content":"正则表达式 1. Safari 处理正则表达式中的正向后行断言时(?\u0026lt;=\u0026hellip;)，异常 1 2 3 4 5 6 // 以下代码在 Chrome 中正常，但在 Safari 中会报错 \u0026#34;https://linlccc.com?theme=light\u0026#34;.replace(/(?\u0026lt;=[?|\u0026amp;]theme=)\\w+/, \u0026#34;dark\u0026#34;); // 解决方案，使用捕捉组+替换字符串的方式 \u0026#34;https://linlccc.com?theme=light\u0026#34;.replace(/([?|\u0026amp;]theme=)\\w+/, \u0026#34;$1dark\u0026#34;); // 以上两个执行结果都是 \u0026#34;https://linlccc.com?theme=dark\u0026#34; ","permalink":"https://linlccc.com/posts/saferisteppingonthepit/","summary":"正则表达式 1. Safari 处理正则表达式中的正向后行断言时(?\u0026lt;=\u0026hellip;)，异常 1 2 3 4 5 6 // 以下代码在 Chrome 中正常，但在 Safari 中会报错 \u0026#34;https://linlccc.com?theme=light\u0026#34;.replace(/(?\u0026lt;=[?|\u0026amp;]theme=)\\w+/, \u0026#34;dark\u0026#34;); // 解决方案，使用捕捉组+替换字符串的方式 \u0026#34;https://linlccc.com?theme=light\u0026#34;.replace(/([?|\u0026amp;]theme=)\\w+/, \u0026#34;$1dark\u0026#34;); // 以上两个执行结果都","title":"踩坑记--Safari之正向后行断言"},{"content":"概念 每一个模板都有一个名为 Page 数据对象\nPage 信息参考：Page 信息参考\n基础语法 访问变量 1 2 {{ .Titel }} // 访问已存在的变量 {{ $address }} // 访问自定义变量 声明变量与赋值 1 2 3 4 {{ $address := \u0026#34;http://www.baidu.com\u0026#34; }} // 声明自定义变量并赋值 {{ $msg := `Line one. Line two.` }} // 支持多行字符串 {{ $msg = \u0026#34;\u0026#34; }} // 将msg的值修改为空字符串 条件语句 条件语句 if/with 都以 {{ end }} 结束\n在hugo模板中，条件语句的条件可以是任何表达式，而不仅仅是布尔类型的表达式，以下情况会被认为是false：\n空字符串 \u0026quot;\u0026quot; 空数组 [] 空字典 map[] 空指针 nil 数值 0 布尔值 false if 很多情况下建议使用 with 语句，而不是 if 语句，因为 with 语句可以重新绑定上下文，而 if 语句不能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 {{ if .IsHome }} {{ end }} // 判断 IsHome 的值 {{ if eq .Title \u0026#34;Home\u0026#34; }} {{ end }} // 判断变量是否相等 {{ if ne .Title \u0026#34;Home\u0026#34; }} {{ end }} // 判断变量是否不相等 {{ if and .IsHome .Params.show }} {{ end }} // 判断多个条件是否同时满足 {{ if or .IsHome .Params.show }} {{ end }} // 判断多个条件是否有一个满足 {{ if not .IsHome }} {{ end }} // 判断条件是否不满足 {{ if strings.Contains \u0026#34;hugo\u0026#34; \u0026#34;go\u0026#34; }} {{end}} // 判断是否包含指定字符串 // 该示例和 with 的第一个示例做完全相同的事 {{ if isset .Params \u0026#34;title\u0026#34; }} \u0026lt;h4\u0026gt;{{ index .Params \u0026#34;title\u0026#34; }}\u0026lt;/h4\u0026gt; {{ end }} // 但是 if 可是使用 else if 语句 {{ if (isset .Params \u0026#34;description\u0026#34;) }} {{ index .Params \u0026#34;description\u0026#34; }} {{ else if (isset .Params \u0026#34;summary\u0026#34;) }} {{ index .Params \u0026#34;summary\u0026#34; }} {{ else }} {{ .Summary }} {{ end }} // 使用 or/and , 只要 .Params.title 或者 .Params.caption 有一个存在，并且 .Params.attr 存在，就会执行该块 {{ if (and (or (isset .Params \u0026#34;title\u0026#34;) (isset .Params \u0026#34;caption\u0026#34;)) (isset .Params \u0026#34;attr\u0026#34;)) }} \u0026lt;div class=\u0026#34;caption {{ index .Params \u0026#34;attr\u0026#34; }}\u0026#34;\u0026gt; {{ if (isset .Params \u0026#34;title\u0026#34;) }} \u0026lt;h4\u0026gt;{{ index .Params \u0026#34;title\u0026#34; }}\u0026lt;/h4\u0026gt; {{ end }} {{ if (isset .Params \u0026#34;caption\u0026#34;) }} \u0026lt;p\u0026gt;{{ index .Params \u0026#34;caption\u0026#34; }}\u0026lt;/p\u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} with with在其范围内重新绑定上下文.\n1 2 3 4 5 6 7 8 9 10 11 // 如果 .Params.title 为空，将跳过该块 {{ with .Params.title }} \u0026lt;h4\u0026gt;{{ . }}\u0026lt;/h4\u0026gt; {{ end }} // 如果 Param 设置了 description，那么输出 Param 的 description，否则输出 Summary {{ with .Param \u0026#34;description\u0026#34; }} {{ . }} {{ else }} {{ .Summary }} {{ end }} 函数调用 在hugo模板中，调用函数格式大致如下：{{ funcName arg1 arg2 \u0026hellip; }}\n模板中函数信息参考：模板中函数信息\n1 2 {{ add 1 2 }} // 调用 add 函数，计算 1+2，结果为3 {{ lt 1 2 }} // 调用 lt 函数，计算1\u0026lt;2，结果为true 迭代 迭代语句 range 以 {{ end }} 结束 使用 range 来迭代 map/array/slice 类型变量\n以下是 range 使用的几个示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 这里的上下文 . 是 $array 中的一个元素，要访问全局上下文，需要使用 $. {{ range $array }} {{ . }} {{ end }} // 为数组元素的值声明变量 {{ range $elem_val := $array }} {{ $elem_val }} {{ end }} // 为数组元素的索引和值声明变量 {{ range $elem_index, $elem_val := $array }} {{ $elem_index }} -- {{ $elem_val }} {{ end }} // 为 map 元素的索引和值声明变量 {{ range $elem_key, $elem_val := $map }} {{ $elem_key }} -- {{ $elem_val }} {{ end }} // 传入的 map/array/slice 为空时，执行 else 语句 {{ range $array }} {{ . }} {{else}} // 只有在 $array 为空时才会执行 {{ end }} 遍历其他示例 1 2 3 4 5 6 {{ range .Data.Pages }} // 遍历 Data.Pages {{ range where .Data.Pages \u0026#34;Section\u0026#34; \u0026#34;posts\u0026#34; }} // 遍历 Data.Pages，过滤 Section 为 posts 的数据 {{ range first 10 .Data.Pages }} // 遍历 Data.Pages，取前10条数据 {{ range last 10 .Data.Pages }} // 遍历 Data.Pages，取后10条数据 {{ range after 10 .Data.Pages }} // 遍历 Data.Pages，取第10条数据之后的数据 {{ range until 10 .Data.Pages }} // 遍历 Data.Pages，取第10条数据之前的数据 cond cond CONTROL VAR1 VAR2 如果 CONTROL 为真，则返回 VAR1，否则返回 VAR2\n模板 模板位置始终从hugo目录中的layouts目录开始查找，如果没有找到，就会从主题目录中查找\n如果在主题目录中也没有找到，就会使用默认的模板\n部分模板 使用 partial 函数引用部分模板，部分模板的位置为 layouts/partials。 语法如下：{{ partial \u0026quot;\u0026lt;PATH\u0026gt;/\u0026lt;PARTIAL\u0026gt;.\u0026lt;EXTENSION\u0026gt;\u0026quot; . }}\n1 2 {{ partial \u0026#34;header.html\u0026#34; . }} 引用部分模板 layouts/partials/header.html {{ partialCached \u0026#34;header.html\u0026#34; . }} 缓存引用部分模板 layouts/partials/header.html 多变量部分模板示例 1 2 3 4 5 6 7 // 传入多个变量 {{ partial \u0026#34;header.html\u0026#34; (dict \u0026#34;curremtPage\u0026#34; . \u0026#34;param1\u0026#34; \u0026#34;1\u0026#34; \u0026#34;param2\u0026#34; \u0026#34;2\u0026#34; ) }} // 模板中使用变量 {{ .curremtPage }} -\u0026gt; . {{ .param1 }} -\u0026gt; \u0026#34;1\u0026#34; {{ .param2 }} -\u0026gt; \u0026#34;2\u0026#34; 引用模板 使用 template 函数引用模板，template 函数用于在更旧的 Hugo 版本中包含部分模板。现在它只对调用内部模板有用。\n内部模板信息参考：内部模板\n查看可用的内部模板：可用的内部模板\n语法如下：{{ template \u0026quot;_internal/\u0026lt;TEMPLATE\u0026gt;.\u0026lt;EXTENSION\u0026gt;\u0026quot; . }}\n1 2 {{ template \u0026#34;_internal/opengraph.html\u0026#34; . }} 引用内部模板 opengraph.html {{ template \u0026#34;_internal/_default/rss.xml\u0026#34; . }} 引用内部模板 _default/rss.xml 空格符 模板会处理以下空白符\n空格 tab 回车 新行 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;div\u0026gt; {{ .Title }} \u0026lt;/div\u0026gt; // 输出 \u0026lt;div\u0026gt; Hello, World! \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {{- .Title -}} \u0026lt;/div\u0026gt; // 输出 \u0026lt;div\u0026gt;Hello, World!\u0026lt;/div\u0026gt; 杂项 1 2 3 4 5 6 7 8 9 10 11 12 13 // 使用名为\u0026#34;main\u0026#34;的块，如果没有定义该块，就会使用默认的块 {{ block \u0026#34;main\u0026#34; . }}{{ end }} // 定义一个名称为\u0026#34;main\u0026#34;的块 {{ define \u0026#34;main\u0026#34; }} \u0026lt;h1\u0026gt;Posts\u0026lt;/h1\u0026gt; {{ range .Pages }} \u0026lt;article\u0026gt; \u0026lt;h2\u0026gt;{{ .Title }}\u0026lt;/h2\u0026gt; {{ .Content }} \u0026lt;/article\u0026gt; {{ end }} {{ end }} 资源 resources 是一个 Hugo 内置的模块，用于处理网站资源文件，例如图片、CSS、JavaScript 等。它包含了一系列的方法，可以用来获取、操作、组合和匹配资源文件。\nresources.Get: 获取指定路径的资源文件。 resources.Match: 根据指定的 glob 模式匹配资源文件，返回一个资源列表。 resources.Concat: 将多个资源文件合并为一个。 resources.FromString: 从字符串中创建一个资源文件。 resources.ExecuteAsTemplate: 将资源文件作为模板进行解析。 ","permalink":"https://linlccc.com/posts/hugotemplatebasicsyntax/","summary":"概念 每一个模板都有一个名为 Page 数据对象 Page 信息参考：Page 信息参考 基础语法 访问变量 1 2 {{ .Titel }} // 访问已存在的变量 {{ $address }} // 访问自定义变量 声明变量与赋值 1 2 3 4 {{ $address := \u0026#34;http://www.baidu.com\u0026#34; }} // 声明自定义变量并赋值 {{ $msg := `Line one. Line two.` }}","title":"hugo 模板基本语法"}]